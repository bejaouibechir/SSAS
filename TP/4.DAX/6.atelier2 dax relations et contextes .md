

# Atelier 2 : Relations et Contexte

## AdventureWorksDW2022 - Maîtriser les Relations DAX

---

## Introduction

Cet atelier approfondit la compréhension des **relations** dans DAX et leur impact sur le **contexte de calcul**. Vous apprendrez à naviguer efficacement entre les tables, à gérer les relations actives et inactives, et à exploiter la puissance des fonctions de navigation.

### Prérequis

Avant de commencer cet atelier, assurez-vous d'avoir :

- Complété l'Atelier 1 (Fondamentaux DAX)
- Une bonne compréhension de CALCULATE et des contextes de filtre
- Le modèle AdventureWorksDW2022 chargé dans Power BI ou Analysis Services

### Architecture des Relations

Le modèle **AdventureWorksDW2022** utilise un schéma en étoile avec :

**Relations Actives** :

- FactInternetSales → DimCustomer (CustomerKey)
- FactInternetSales → DimProduct (ProductKey)
- FactInternetSales → DimDate (OrderDateKey) ✅
- FactInternetSales → DimCurrency (CurrencyKey)
- DimCustomer → DimGeography (GeographyKey)
- DimProduct → DimProductSubcategory (ProductSubcategoryKey)
- DimProductSubcategory → DimProductCategory (ProductCategoryKey)
- DimGeography → DimSalesTerritory (SalesTerritoryKey)

**Relations Inactives** :

- FactInternetSales → DimDate (ShipDateKey) ⏸️
- FactInternetSales → DimDate (DueDateKey) ⏸️
- FactInternetSales → DimSalesTerritory (SalesTerritoryKey) ⏸️

---

## 5. Comprendre RELATED vs RELATEDTABLE

### Concepts Fondamentaux

**RELATED** et **RELATEDTABLE** sont deux fonctions complémentaires qui exploitent les relations du modèle :

- **RELATED** : navigue du côté "Many" vers le côté "One" (⬆️ montée)
- **RELATEDTABLE** : navigue du côté "One" vers le côté "Many" (⬇️ descente)

### Visualisation de la Navigation



DimProductCategory (One)
        ⬆️ RELATED
        ⬇️ RELATEDTABLE
DimProductSubcategory (Many/One)
        ⬆️ RELATED
        ⬇️ RELATEDTABLE
DimProduct (Many/One)
        ⬆️ RELATED
        ⬇️ RELATEDTABLE
FactInternetSales (Many)

### Walkthrough 5.1 : RELATED - Remonter la Hiérarchie

1. **Objectif** : Enrichir la table de faits avec des informations de dimension

2. Créez une colonne calculée dans **FactInternetSales** pour obtenir le nom du produit :




       Nom Produit = RELATED(DimProduct[EnglishProductName])

3. **Explication détaillée** :
   
   - La formule s'exécute dans le **contexte de ligne** de FactInternetSales
   - Pour chaque ligne, DAX suit la relation via ProductKey
   - Récupère la valeur EnglishProductName de la ligne correspondante dans DimProduct

4. **Vérification** : Ajoutez cette colonne dans une table visuelle et comparez avec ProductKey

5. Créez une colonne calculée multi-niveaux pour obtenir la catégorie :

```dax
Catégorie Produit = 
RELATED(DimProductCategory[EnglishProductCategoryName])
```

6. **Point clé** : DAX suit automatiquement la chaîne de relations :
   - FactInternetSales → DimProduct (via ProductKey)
   - DimProduct → DimProductSubcategory (via ProductSubcategoryKey)
   - DimProductSubcategory → DimProductCategory (via ProductCategoryKey)

### Walkthrough 5.2 : RELATED dans les Mesures

1. **Scénario** : Calculer le montant des ventes avec une majoration basée sur la couleur du produit

2. Créez cette mesure complexe :

```dax
Ventes avec Majoration Couleur = 
SUMX(
    FactInternetSales,
    VAR ProductColor = RELATED(DimProduct[Color])
    VAR Majoration = 
        SWITCH(
            ProductColor,
            "Red", 1.10,
            "Blue", 1.05,
            "Black", 1.15,
            1.00
        )
    RETURN
        FactInternetSales[SalesAmount] * Majoration
)
```

3. **Explication pas à pas** :
   
   - **SUMX** crée un contexte de ligne sur FactInternetSales
   - **VAR ProductColor** utilise RELATED pour obtenir la couleur
   - **VAR Majoration** détermine le coefficient selon la couleur
   - **RETURN** applique la majoration ligne par ligne

4. **Testez** : Comparez avec `[Ventes Totales]` pour voir l'impact des majorations

### Walkthrough 5.3 : RELATEDTABLE - Descendre vers les Faits

1. **Objectif** : Calculer des agrégations au niveau dimension basées sur les faits

2. Créez une colonne calculée dans **DimProduct** pour compter les ventes :

```dax
Nombre de Ventes = COUNTROWS(RELATEDTABLE(FactInternetSales))
```

3. **Mécanisme** :
   
   - S'exécute dans le contexte de ligne de DimProduct
   - Pour chaque produit, RELATEDTABLE retourne **toutes** les lignes de ventes associées
   - COUNTROWS compte ces lignes

4. **Attention** ⚠️ : Cette colonne est calculée à l'import et ne se met pas à jour avec les filtres
   
   - Elle contient le nombre **total** de ventes pour chaque produit
   - Préférez les mesures pour des calculs dynamiques

5. Créez une **mesure** équivalente (recommandée) :

```dax
Nombre de Ventes (Mesure) = 
SUMX(
    VALUES(DimProduct[ProductKey]),
    COUNTROWS(RELATEDTABLE(FactInternetSales))
)
```

6. **Différence clé** :
   - La colonne calculée : valeur fixe, calculée une fois
   - La mesure : recalculée selon le contexte de filtre actuel

### Walkthrough 5.4 : RELATEDTABLE pour Agrégations Complexes

1. **Scénario** : Calculer le revenu moyen par transaction pour chaque client

2. Créez cette mesure :

```dax
Revenu Moyen par Transaction = 
AVERAGEX(
    VALUES(DimCustomer[CustomerKey]),
    VAR CustomerSales = RELATEDTABLE(FactInternetSales)
    VAR TotalRevenue = SUMX(CustomerSales, FactInternetSales[SalesAmount])
    VAR TransactionCount = COUNTROWS(CustomerSales)
    RETURN
        DIVIDE(TotalRevenue, TransactionCount)
)
```

3. **Explication détaillée** :
   
   - **VALUES(DimCustomer[CustomerKey])** crée une table des clients visibles
   - **AVERAGEX** itère sur chaque client
   - **VAR CustomerSales** récupère toutes les ventes du client actuel via RELATEDTABLE
   - **VAR TotalRevenue** somme les montants de ces ventes
   - **VAR TransactionCount** compte le nombre de transactions
   - **DIVIDE** calcule la moyenne par transaction
   - Enfin, AVERAGEX fait la moyenne de tous ces résultats

4. **Testez** dans une matrice avec CustomerKey et cette mesure

### Walkthrough 5.5 : Comparaison RELATED vs LOOKUPVALUE

1. **Alternative à RELATED** : La fonction LOOKUPVALUE

2. Créez deux colonnes calculées équivalentes dans FactInternetSales :

```dax
// Méthode 1 : RELATED (recommandée)
Nom Produit (RELATED) = 
RELATED(DimProduct[EnglishProductName])

// Méthode 2 : LOOKUPVALUE
Nom Produit (LOOKUPVALUE) = 
LOOKUPVALUE(
    DimProduct[EnglishProductName],
    DimProduct[ProductKey],
    FactInternetSales[ProductKey]
)
```

3. **Comparaison** :

| Critère         | RELATED              | LOOKUPVALUE            |
| --------------- | -------------------- | ---------------------- |
| **Performance** | ⚡⚡⚡ Très rapide      | ⚡ Plus lent            |
| **Simplicité**  | ✅ Simple             | ❌ Verbeux              |
| **Relations**   | ✅ Suit les relations | ❌ Ignore les relations |
| **Flexibilité** | ❌ Relation requise   | ✅ Recherche libre      |

4. **Quand utiliser LOOKUPVALUE ?**
   
   - Quand aucune relation n'existe
   - Pour des recherches basées sur plusieurs critères
   - Pour des recherches dans des tables non liées

5. **Exemple LOOKUPVALUE multi-critères** :

```dax
Produit Trouvé = 
LOOKUPVALUE(
    DimProduct[EnglishProductName],
    DimProduct[ProductKey], FactInternetSales[ProductKey],
    DimProduct[Color], "Red"
)
```

### Tableau Récapitulatif RELATED vs RELATEDTABLE

| Aspect            | RELATED                     | RELATEDTABLE                   |
| ----------------- | --------------------------- | ------------------------------ |
| **Direction**     | Many → One (⬆️)             | One → Many (⬇️)                |
| **Retourne**      | Valeur scalaire             | Table                          |
| **Usage typique** | Colonnes calculées          | Agrégations                    |
| **Exemple**       | Nom du produit depuis vente | Toutes les ventes d'un produit |
| **Contexte**      | Ligne (row context)         | Ligne (row context)            |
| **Performance**   | ⚡⚡⚡ Très rapide             | ⚡⚡ Rapide                      |

---

## 6. Scénario 4 : Impact des Relations Actives/Inactives

### Comprendre les Relations Actives vs Inactives

**Règle fondamentale** : Entre deux tables, une seule relation peut être active à la fois. Les autres doivent être inactives.

**Dans AdventureWorksDW2022** :

- FactInternetSales a **3 clés de date** : OrderDateKey (✅ active), ShipDateKey (⏸️ inactive), DueDateKey (⏸️ inactive)
- Une seule relation vers DimDate peut être active par défaut

### Walkthrough 6.1 : Identifier les Relations Actives

1. **Dans Power BI Desktop** :
   
   - Ouvrez la vue **Modèle**
   - Les relations **actives** sont affichées en **trait plein** (━━━)
   - Les relations **inactives** sont affichées en **trait pointillé** (┄┄┄)

2. **Vérification via DAX Studio** :

```dax
EVALUATE
SELECTCOLUMNS(
    FactInternetSales,
    "OrderDateKey", FactInternetSales[OrderDateKey],
    "OrderDate", RELATED(DimDate[FullDateAlternateKey]),
    "ShipDateKey", FactInternetSales[ShipDateKey],
    "ShipDate Direct", RELATED(DimDate[FullDateAlternateKey])
)
```

3. **Résultat attendu** :
   - La colonne "OrderDate" fonctionne ✅
   - La colonne "ShipDate Direct" affiche OrderDate (pas ShipDate) ⚠️
   - Pourquoi ? RELATED utilise automatiquement la relation active

### Walkthrough 6.2 : Comportement par Défaut des Relations Actives

1. **Créez une mesure simple** :

```dax
Ventes Totales = SUM(FactInternetSales[SalesAmount])
```

2. **Testez dans une matrice** :
   
   - En ligne : DimDate[CalendarYear]
   - Valeurs : [Ventes Totales]

3. **Observation** : Les ventes sont agrégées par année de **commande** (OrderDate), pas d'expédition

4. **Explication** : Par défaut, les filtres sur DimDate se propagent via la relation **active** (OrderDateKey)

### Walkthrough 6.3 : Problème - Analyser par Date d'Expédition

1. **Challenge** : Vous voulez analyser les ventes par date **d'expédition**, pas de commande

2. **Tentative naïve (ne fonctionne pas)** :

```dax
// ❌ NE FONCTIONNE PAS - utilise toujours OrderDate
Ventes par Expédition (ERREUR) = SUM(FactInternetSales[SalesAmount])
```

3. **Pourquoi ça ne fonctionne pas ?**
   - Les filtres sur DimDate utilisent toujours la relation active
   - La relation ShipDateKey → DateKey est inactive
   - Les filtres ne se propagent pas via cette relation

### Walkthrough 6.4 : Solution avec USERELATIONSHIP

1. **La fonction USERELATIONSHIP** active temporairement une relation inactive

2. **Créez la mesure correcte** :

```dax
Ventes par Date Expédition = 
CALCULATE(
    SUM(FactInternetSales[SalesAmount]),
    USERELATIONSHIP(
        FactInternetSales[ShipDateKey],
        DimDate[DateKey]
    )
)
```

3. **Mécanisme détaillé** :
   
   - **CALCULATE** évalue la somme dans un contexte modifié
   - **USERELATIONSHIP** désactive temporairement la relation OrderDateKey
   - Et active temporairement la relation ShipDateKey
   - Les filtres sur DimDate se propagent maintenant via ShipDateKey

4. **Testez côte à côte** :

| CalendarYear | Ventes Totales (Order) | Ventes par Date Expédition |
| ------------ | ---------------------- | -------------------------- |
| 2011         | 3,266,374              | 1,234,567                  |
| 2012         | 6,530,344              | 5,432,123                  |
| 2013         | 9,791,060              | 9,876,543                  |

5. **Observation** : Les montants diffèrent car certaines commandes de 2011 ont été expédiées en 2012

### Walkthrough 6.5 : Analyser le Délai de Livraison

1. **Objectif** : Calculer le délai moyen entre commande et expédition

2. **Approche** : Comparer les dates via les deux relations

```dax
Délai Moyen Livraison (Jours) = 
AVERAGEX(
    FactInternetSales,
    VAR OrderDate = RELATED(DimDate[FullDateAlternateKey])
    VAR ShipDate = 
        CALCULATE(
            VALUES(DimDate[FullDateAlternateKey]),
            USERELATIONSHIP(
                FactInternetSales[ShipDateKey],
                DimDate[DateKey]
            )
        )
    RETURN
        DATEDIFF(OrderDate, ShipDate, DAY)
)
```

3. **Explication détaillée** :
   
   - **AVERAGEX** itère sur chaque vente
   - **VAR OrderDate** utilise la relation active (OrderDateKey)
   - **VAR ShipDate** utilise USERELATIONSHIP pour activer ShipDateKey
   - **DATEDIFF** calcule la différence en jours
   - **AVERAGEX** fait la moyenne de tous les délais

4. **Attention** ⚠️ : VALUES retourne une table. Utilisez cette version corrigée :

```dax
Délai Moyen Livraison (Jours) = 
AVERAGEX(
    FactInternetSales,
    VAR OrderDateKey = FactInternetSales[OrderDateKey]
    VAR ShipDateKey = FactInternetSales[ShipDateKey]
    RETURN
        ShipDateKey - OrderDateKey
)
```

5. **Testez** : Ajoutez cette mesure dans une carte pour voir le délai moyen global

### Walkthrough 6.6 : Comparer Trois Dates Simultanément

1. **Challenge** : Créer un tableau comparant les ventes par OrderDate, ShipDate et DueDate

2. **Créez trois mesures distinctes** :

```dax
Ventes par Date Commande = 
SUM(FactInternetSales[SalesAmount])

Ventes par Date Expédition = 
CALCULATE(
    SUM(FactInternetSales[SalesAmount]),
    USERELATIONSHIP(FactInternetSales[ShipDateKey], DimDate[DateKey])
)

Ventes par Date Échéance = 
CALCULATE(
    SUM(FactInternetSales[SalesAmount]),
    USERELATIONSHIP(FactInternetSales[DueDateKey], DimDate[DateKey])
)
```

3. **Créez une matrice** :
   
   - Lignes : DimDate[CalendarYear]
   - Valeurs : Les trois mesures

4. **Analyse** : Observez comment les montants se décalent selon la perspective temporelle

### Walkthrough 6.7 : Relation Inactive sur DimSalesTerritory

1. **Contexte** : FactInternetSales a une relation inactive vers DimSalesTerritory (la relation active passe par DimCustomer → DimGeography)

2. **Créez une mesure utilisant la relation directe** :

```dax
Ventes par Territoire Direct = 
CALCULATE(
    SUM(FactInternetSales[SalesAmount]),
    USERELATIONSHIP(
        FactInternetSales[SalesTerritoryKey],
        DimSalesTerritory[SalesTerritoryKey]
    )
)
```

3. **Comparez** avec la mesure standard :

```dax
Ventes par Territoire (via Client) = 
SUM(FactInternetSales[SalesAmount])
```

4. **Testez** : Ajoutez SalesTerritoryRegion en ligne et les deux mesures

5. **Question** : Les résultats sont-ils identiques ? Pourquoi ?

6. **Réponse** : Les montants peuvent différer si certains territoires dans FactInternetSales ne correspondent pas aux territoires des clients

### Bonnes Pratiques - Relations Actives/Inactives

✅ **À FAIRE** :

- Nommer clairement les mesures selon la date utilisée (ex: "Ventes par Date Expédition")
- Documenter quelle relation est utilisée dans les descriptions de mesures
- Utiliser USERELATIONSHIP uniquement quand nécessaire
- Tester les mesures dans différents contextes de filtre

❌ **À ÉVITER** :

- Activer/désactiver manuellement les relations dans le modèle pour chaque analyse
- Créer des mesures ambiguës sans indiquer quelle date est utilisée
- Utiliser USERELATIONSHIP dans des colonnes calculées (ne fonctionne pas)
- Imbriquer plusieurs USERELATIONSHIP (risque de confusion)

---

## 7. Scénario 5 : Navigation Multi-Niveaux

### Comprendre les Chaînes de Relations

Dans un modèle en étoile, les tables de dimension peuvent être organisées en **hiérarchies** :

```
DimProductCategory (Niveau 1)
    ↓ ProductCategoryKey
DimProductSubcategory (Niveau 2)
    ↓ ProductSubcategoryKey
DimProduct (Niveau 3)
    ↓ ProductKey
FactInternetSales (Faits)
```

DAX navigue **automatiquement** à travers ces chaînes de relations.

### Walkthrough 7.1 : Navigation Ascendante Simple

1. **Objectif** : Depuis FactInternetSales, récupérer la catégorie du produit (2 niveaux au-dessus)

2. **Méthode directe avec RELATED** :

```dax
// Colonne calculée dans FactInternetSales
Catégorie du Produit = 
RELATED(DimProductCategory[EnglishProductCategoryName])
```

3. **Ce qui se passe en arrière-plan** :
   
   - DAX suit FactInternetSales[ProductKey] → DimProduct[ProductKey]
   - Puis suit DimProduct[ProductSubcategoryKey] → DimProductSubcategory[ProductSubcategoryKey]
   - Enfin suit DimProductSubcategory[ProductCategoryKey] → DimProductCategory[ProductCategoryKey]
   - Retourne EnglishProductCategoryName

4. **Testez** : Créez la colonne et vérifiez qu'elle affiche "Bikes", "Clothing", etc.

### Walkthrough 7.2 : Navigation via Géographie

1. **Hiérarchie géographique** :

```
DimSalesTerritory (Pays/Région)
    ↑ SalesTerritoryKey
DimGeography (Ville/Province)
    ↑ GeographyKey
DimCustomer (Client)
    ↑ CustomerKey
FactInternetSales (Ventes)
```

2. **Créez une mesure pour obtenir le pays du client** :

```dax
Pays Client = 
CONCATENATEX(
    VALUES(DimSalesTerritory[SalesTerritoryCountry]),
    DimSalesTerritory[SalesTerritoryCountry],
    ", "
)
```

3. **Navigation automatique** : Quand vous filtrez sur DimCustomer, DAX suit automatiquement :
   
   - DimCustomer → DimGeography (via GeographyKey)
   - DimGeography → DimSalesTerritory (via SalesTerritoryKey)

4. **Testez** dans une matrice :
   
   - Lignes : DimCustomer[CustomerKey]
   - Valeurs : [Pays Client], [Ventes Totales]

### Walkthrough 7.3 : Compter les Niveaux Descendants

1. **Objectif** : Pour chaque catégorie, compter combien de produits distincts ont été vendus

2. **Approche multi-niveaux** :

```dax
Produits Vendus par Catégorie = 
CALCULATE(
    DISTINCTCOUNT(FactInternetSales[ProductKey]),
    ALLEXCEPT(
        DimProduct,
        DimProductCategory[EnglishProductCategoryName]
    )
)
```

3. **Explication** :
   
   - **DISTINCTCOUNT** compte les ProductKey uniques dans les ventes
   - **ALLEXCEPT** ignore tous les filtres sur DimProduct SAUF la catégorie
   - Le résultat : nombre de produits vendus dans la catégorie actuelle

4. **Testez** dans une matrice :
   
   - Lignes : DimProductCategory[EnglishProductCategoryName]
   - Valeurs : [Produits Vendus par Catégorie]

5. **Résultat attendu** :
   
   - Bikes : ~125 produits
   - Clothing : ~48 produits
   - Accessories : ~35 produits

### Walkthrough 7.4 : Agrégation en Cascade

1. **Scénario** : Calculer les ventes moyennes par sous-catégorie pour chaque catégorie

2. **Mesure complexe** :

```dax
Ventes Moyennes par Sous-Catégorie = 
AVERAGEX(
    VALUES(DimProductSubcategory[ProductSubcategoryKey]),
    CALCULATE(SUM(FactInternetSales[SalesAmount]))
)
```

3. **Mécanisme** :
   
   - **VALUES** liste toutes les sous-catégories visibles
   - **AVERAGEX** itère sur chaque sous-catégorie
   - **CALCULATE** calcule les ventes de cette sous-catégorie
   - **AVERAGEX** fait la moyenne de tous ces montants

4. **Testez** avec différents niveaux de granularité :
   
   - Au niveau Catégorie : moyenne des sous-catégories
   - Au niveau Sous-catégorie : ventes de cette sous-catégorie
   - Au niveau Produit : ventes de ce produit

### Walkthrough 7.5 : Remonter la Hiérarchie avec TREATAS

1. **Problème** : Vous avez une table déconnectée et voulez filtrer via une hiérarchie

2. **Créez une table de paramètres** :

```dax
// Table calculée
Catégories Cibles = 
DISTINCT(DimProductCategory[EnglishProductCategoryName])
```

3. **Utilisez TREATAS pour établir un filtre virtuel** :

```dax
Ventes Catégorie Sélectionnée = 
CALCULATE(
    SUM(FactInternetSales[SalesAmount]),
    TREATAS(
        VALUES('Catégories Cibles'[EnglishProductCategoryName]),
        DimProductCategory[EnglishProductCategoryName]
    )
)
```

4. **Explication** :
   
   - **TREATAS** traite la sélection dans la table déconnectée
   - Comme si c'était un filtre sur DimProductCategory
   - Le filtre se propage ensuite naturellement vers FactInternetSales

5. **Testez** : Créez un segment sur la table Catégories Cibles et observez l'effet

### Walkthrough 7.6 : Navigation Conditionnelle

1. **Scénario** : Afficher le nom de catégorie, mais seulement pour les produits chers (>$1000)

2. **Mesure avec condition** :

```dax
Catégorie Produits Premium = 
VAR ProductPrice = MAX(DimProduct[ListPrice])
VAR CategoryName = RELATED(DimProductCategory[EnglishProductCategoryName])
RETURN
    IF(
        ProductPrice > 1000,
        CategoryName,
        "Standard"
    )
```

3. **Attention** ⚠️ : Cette mesure fonctionne au niveau produit. Au niveau catégorie, MAX retourne le prix le plus élevé de la catégorie

4. **Version corrigée pour mesure** :

```dax
Ventes Produits Premium par Catégorie = 
CALCULATE(
    SUM(FactInternetSales[SalesAmount]),
    FILTER(
        ALL(DimProduct),
        RELATED(DimProductCategory[EnglishProductCategoryName]) = 
            VALUES(DimProductCategory[EnglishProductCategoryName]) &&
        DimProduct[ListPrice] > 1000
    )
)
```

### Walkthrough 7.7 : Détection de Rupture de Chaîne

1. **Problème potentiel** : Certains produits n'ont pas de sous-catégorie (valeur NULL)

2. **Mesure pour détecter les produits orphelins** :

```dax
Produits Sans Sous-Catégorie = 
COUNTROWS(
    FILTER(
        DimProduct,
        ISBLANK(DimProduct[ProductSubcategoryKey])
    )
)
```

3. **Impact sur les ventes** :

```dax
Ventes Produits Sans Catégorie = 
CALCULATE(
    SUM(FactInternetSales[SalesAmount]),
    FILTER(
        ALL(DimProduct),
        ISBLANK(DimProduct[ProductSubcategoryKey])
    )
)
```

4. **Testez** : Si cette mesure retourne un montant, vous avez des données à nettoyer

### Bonnes Pratiques - Navigation Multi-Niveaux

✅ **À FAIRE** :

- Documenter les chaînes de relations dans votre modèle
- Tester les mesures à chaque niveau de granularité
- Utiliser RELATED pour les navigations simples (plus performant)
- Vérifier l'intégrité référentielle (pas de clés orphelines)

❌ **À ÉVITER** :

- Utiliser LOOKUPVALUE quand RELATED fonctionne
- Créer des chaînes circulaires de relations
- Ignorer les valeurs NULL dans les clés de jointure
- Utiliser RELATEDTABLE dans des colonnes calculées de tables de faits (performances)

---

## 8. Scénario 6 : USERELATIONSHIP pour Dates Multiples

### Comprendre les Scénarios de Dates Multiples

De nombreuses tables de faits contiennent **plusieurs dates** :

- **FactInternetSales** : OrderDate, ShipDate, DueDate
- **Projets** : StartDate, EndDate, MilestoneDate
- **Commandes** : CreatedDate, ApprovedDate, CompletedDate

Chaque date peut être analysée via la même table calendrier (**DimDate**).

### Walkthrough 8.1 : Architecture de Dates Multiples

1. **État actuel du modèle** :

```
DimDate (Table calendrier unique)
    ↓ DateKey (Active) ✅
FactInternetSales[OrderDateKey]

    DateKey (Inactive) ⏸️
FactInternetSales[ShipDateKey]

    DateKey (Inactive) ⏸️
FactInternetSales[DueDateKey]
```

2. **Principe** : Une seule table DimDate, trois relations différentes

3. **Vérifiez** dans la vue Modèle :
   
   - Ligne pleine entre OrderDateKey et DateKey
   - Lignes pointillées pour ShipDateKey et DueDateKey

### Walkthrough 8.2 : Créer un Ensemble de Mesures Temporelles

1. **Pattern recommandé** : Créer une mesure de base et des variantes pour chaque date

2. **Mesure de base** :

```dax
Ventes Totales = SUM(FactInternetSales[SalesAmount])
```

3. **Variantes par type de date** :

```dax
Ventes par Date Commande = 
[Ventes Totales]
// Utilise automatiquement la relation active (OrderDateKey)

Ventes par Date Expédition = 
CALCULATE(
    [Ventes Totales],
    USERELATIONSHIP(FactInternetSales[ShipDateKey], DimDate[DateKey])
)

Ventes par Date Échéance = 
CALCULATE(
    [Ventes Totales],
    USERELATIONSHIP(FactInternetSales[DueDateKey], DimDate[DateKey])
)
```

4. **Avantage** : Toute modification de [Ventes Totales] se propage automatiquement aux trois variantes

### Walkthrough 8.3 : Analyse Comparative des Dates

1. **Objectif** : Créer un tableau comparant les ventes selon les trois perspectives

2. **Créez une matrice** :
   
   - Lignes : DimDate[CalendarYear], DimDate[EnglishMonthName]
   - Valeurs : Les trois mesures créées ci-dessus

3. **Créez une mesure d'écart** :

```dax
Écart Commande-Expédition = 
[Ventes par Date Commande] - [Ventes par Date Expédition]
```

4. **Interprétation** :
   
   - Écart positif : Plus de commandes que d'expéditions ce mois (commandes en attente)
   - Écart négatif : Plus d'expéditions que de commandes (traitement de backlog)

5. **Créez une mesure de pourcentage** :

```dax
% Ventes Expédiées = 
DIVIDE(
    [Ventes par Date Expédition],
    [Ventes par Date Commande]
)
```

### Walkthrough 8.4 : Time Intelligence avec Dates Multiples

1. **Challenge** : Les fonctions Time Intelligence (SAMEPERIODLASTYEAR, etc.) utilisent la relation active

2. **Solution** : Combiner Time Intelligence et USERELATIONSHIP

3. **Exemple - Ventes de l'année précédente par date d'expédition** :

```dax
Ventes N-1 (Date Expédition) = 
CALCULATE(
    [Ventes Totales],
    USERELATIONSHIP(FactInternetSales[ShipDateKey], DimDate[DateKey]),
    SAMEPERIODLASTYEAR(DimDate[FullDateAlternateKey])
)
```

4. **Explication** :
   
   - **USERELATIONSHIP** active la relation ShipDateKey
   - **SAMEPERIODLASTYEAR** décale ensuite les dates d'un an
   - Les deux modifications de contexte se cumulent

5. **Testez** : Comparez avec la même mesure sur OrderDate

```dax
Ventes N-1 (Date Commande) = 
CALCULATE(
    [Ventes Totales],
    SAMEPERIODLASTYEAR(DimDate[FullDateAlternateKey])
)
```

### Walkthrough 8.5 : Cumul YTD avec Dates Alternatives

1. **Objectif** : Calculer le cumul depuis le début de l'année pour les expéditions

2. **Mesure YTD sur date d'expédition** :

```dax
Ventes YTD (Date Expédition) = 
CALCULATE(
    [Ventes Totales],
    USERELATIONSHIP(FactInternetSales[ShipDateKey], DimDate[DateKey]),
    DATESYTD(DimDate[FullDateAlternateKey])
)
```

3. **Important** ⚠️ : L'ordre des paramètres dans CALCULATE compte

4. **Vérification** : Testez par mois et assurez-vous que le cumul redémarre en janvier

### Walkthrough 8.6 : Période Mobile avec Date Personnalisée

1. **Scénario** : Calculer les ventes des 90 derniers jours par date d'expédition

2. **Approche** :

```dax
Ventes 90 Jours (Date Expédition) = 
CALCULATE(
    [Ventes Totales],
    USERELATIONSHIP(FactInternetSales[ShipDateKey], DimDate[DateKey]),
    DATESINPERIOD(
        DimDate[FullDateAlternateKey],
        MAX(DimDate[FullDateAlternateKey]),
        -90,
        DAY
    )
)
```

3. **Mécanisme** :
   
   - **USERELATIONSHIP** change la perspective temporelle à ShipDate
   - **DATESINPERIOD** calcule une fenêtre glissante de 90 jours
   - **MAX(DimDate[...])** prend la date la plus récente dans le contexte

4. **Testez** : Ajoutez cette mesure dans un graphique en ligne avec les dates

### Walkthrough 8.7 : Mesure Combinée - Délai de Livraison

1. **Objectif avancé** : Calculer le délai moyen de livraison en utilisant OrderDate et ShipDate

2. **Première approche (incorrecte)** :

```dax
// ❌ NE FONCTIONNE PAS
Délai Livraison (ERREUR) = 
[Ventes par Date Expédition] - [Ventes par Date Commande]
```

3. **Pourquoi ça ne fonctionne pas ?** On ne peut pas soustraire des dates via USERELATIONSHIP de cette façon

4. **Approche correcte** :

```dax
Délai Moyen Livraison = 
AVERAGEX(
    FILTER(
        FactInternetSales,
        NOT(ISBLANK(FactInternetSales[ShipDateKey])) &&
        NOT(ISBLANK(FactInternetSales[OrderDateKey]))
    ),
    FactInternetSales[ShipDateKey] - FactInternetSales[OrderDateKey]
)
```

5. **Explication** :
   
   - On travaille directement avec les colonnes de dates (DateKey)
   - **FILTER** exclut les lignes avec dates manquantes
   - **AVERAGEX** calcule la moyenne des différences
   - Les DateKey sont des nombres entiers (format yyyymmdd), la soustraction donne approximativement le nombre de jours

6. **Version améliorée avec dates réelles** :

```dax
Délai Moyen Livraison (Jours) = 
AVERAGEX(
    FILTER(
        FactInternetSales,
        NOT(ISBLANK(FactInternetSales[ShipDate])) &&
        NOT(ISBLANK(FactInternetSales[OrderDate]))
    ),
    DATEDIFF(
        FactInternetSales[OrderDate],
        FactInternetSales[ShipDate],
        DAY
    )
)
```

### Walkthrough 8.8 : Switcher Dynamiquement entre les Dates

1. **Objectif** : Permettre à l'utilisateur de choisir quelle date utiliser

2. **Créez une table de paramètres** :

```dax
// Table calculée
Sélecteur de Date = 
DATATABLE(
    "Type Date", STRING,
    "Ordre", INTEGER,
    {
        {"Date de Commande", 1},
        {"Date d'Expédition", 2},
        {"Date d'Échéance", 3}
    }
)
```

3. **Créez une mesure dynamique** :

```dax
Ventes par Date Sélectionnée = 
VAR SelectedDateType = SELECTEDVALUE('Sélecteur de Date'[Type Date], "Date de Commande")
VAR Result = 
    SWITCH(
        SelectedDateType,
        "Date de Commande", [Ventes par Date Commande],
        "Date d'Expédition", [Ventes par Date Expédition],
        "Date d'Échéance", [Ventes par Date Échéance],
        BLANK()
    )
RETURN Result
```

4. **Utilisation** :
   
   - Créez un segment (slicer) sur Sélecteur de Date[Type Date]
   - Ajoutez la mesure [Ventes par Date Sélectionnée] dans vos visuels
   - L'utilisateur peut basculer entre les perspectives temporelles

5. **Avantage** : Un seul visuel, trois analyses possibles

### Walkthrough 8.9 : Gérer les Dates Manquantes

1. **Problème** : Certaines ventes n'ont pas de ShipDate (pas encore expédiées)

2. **Mesure pour compter les commandes non expédiées** :

```dax
Commandes Non Expédiées = 
COUNTROWS(
    FILTER(
        FactInternetSales,
        ISBLANK(FactInternetSales[ShipDateKey])
    )
)
```

3. **Ajuster la mesure de ventes par expédition** :

```dax
Ventes Expédiées Uniquement = 
CALCULATE(
    [Ventes Totales],
    USERELATIONSHIP(FactInternetSales[ShipDateKey], DimDate[DateKey]),
    NOT(ISBLANK(FactInternetSales[ShipDateKey]))
)
```

4. **Calcul du montant en attente** :

```dax
Ventes En Attente Expédition = 
CALCULATE(
    [Ventes Totales],
    ISBLANK(FactInternetSales[ShipDateKey])
)
```

5. **Vérification** :

```dax
Ventes Totales = 
[Ventes Expédiées Uniquement] + [Ventes En Attente Expédition]
```

### Bonnes Pratiques - Dates Multiples

✅ **À FAIRE** :

- Créer une convention de nommage claire (ex: "Ventes par Date X")
- Utiliser une seule table DimDate pour toutes les relations de dates
- Documenter quelle relation est active par défaut
- Tester les mesures avec et sans données manquantes
- Créer des mesures de base réutilisables

❌ **À ÉVITER** :

- Créer plusieurs tables DimDate (une par type de date) - c'est inefficace
- Utiliser USERELATIONSHIP sans nommer clairement la mesure
- Oublier de gérer les valeurs NULL dans les dates
- Imbriquer plusieurs USERELATIONSHIP dans la même mesure
- Utiliser USERELATIONSHIP dans des colonnes calculées (ne fonctionne pas)

### Pattern Avancé - Template de Mesures Temporelles

```dax
// Mesure de base
_Base Ventes = SUM(FactInternetSales[SalesAmount])

// Template pour chaque type de date
Ventes par [TYPE_DATE] = 
VAR UseRelationship = [RELATIONSHIP_EXPRESSION]
RETURN
    CALCULATE([_Base Ventes], UseRelationship)

// YTD Template
Ventes YTD par [TYPE_DATE] = 
CALCULATE(
    [Ventes par [TYPE_DATE]],
    DATESYTD(DimDate[FullDateAlternateKey])
)

// N-1 Template
Ventes N-1 par [TYPE_DATE] = 
CALCULATE(
    [Ventes par [TYPE_DATE]],
    SAMEPERIODLASTYEAR(DimDate[FullDateAlternateKey])
)
```

Remplacez `[TYPE_DATE]` et `[RELATIONSHIP_EXPRESSION]` pour chaque variante.

---

## Conclusion

Cet atelier vous a permis de maîtriser :

✅ **RELATED vs RELATEDTABLE** : navigation bidirectionnelle dans les relations  
✅ **Relations actives/inactives** : comprendre et contrôler avec USERELATIONSHIP  
✅ **Navigation multi-niveaux** : exploiter les chaînes de relations automatiquement  
✅ **Dates multiples** : analyser les mêmes données sous différentes perspectives temporelles  

### Points Clés à Retenir

1. **RELATED** monte (Many → One), **RELATEDTABLE** descend (One → Many)
2. Une seule relation peut être **active** entre deux tables
3. **USERELATIONSHIP** active temporairement une relation inactive
4. DAX suit **automatiquement** les chaînes de relations
5. Utilisez une **seule** table DimDate pour toutes vos relations de dates

# 