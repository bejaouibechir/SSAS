# Atelier 1 : Fondamentaux DAX avec Sc√©narios

## AdventureWorksDW2022 - Guide Pratique

---

## Introduction

Cet atelier vous guide √† travers les fondamentaux de **DAX** (Data Analysis Expressions) en utilisant le mod√®le **AdventureWorksDW2022**. Chaque section inclut des explications d√©taill√©es, des exemples pratiques et des sc√©narios d'application.

### Architecture du Mod√®le

Le mod√®le comprend les tables suivantes :

- **FactInternetSales** : table de faits avec SalesAmount, OrderQuantity, etc.
- **DimProduct, DimProductCategory, DimProductSubcategory** : hi√©rarchie produits
- **DimCustomer, DimGeography** : informations clients
- **DimDate** : dimension temporelle
- **DimCurrency, DimPromotion, DimSalesTerritory** : dimensions additionnelles

---

## 1. La Fonction EVALUATE

La fonction **EVALUATE** permet d'ex√©cuter des requ√™tes DAX et de retourner des tables de r√©sultats. C'est un outil essentiel pour tester et comprendre vos formules DAX.

### Syntaxe de Base

```dax
EVALUATE
<expression_table>
```

### Walkthrough 1.1 : Premi√®re Requ√™te

1. Ouvrez **DAX Studio** ou l'√©diteur de requ√™tes DAX

2. Ex√©cutez cette requ√™te simple pour afficher les 10 premi√®res lignes de la table **DimProduct** :
   
   ```dax
   EVALUATE
   TOPN(10, DimProduct)
   ```

3. Observez le r√©sultat : vous voyez toutes les colonnes de la table

4. **Point cl√©** : **EVALUATE** retourne toujours une table, jamais une valeur scalaire

### Walkthrough 1.2 : S√©lectionner des Colonnes

1. Pour afficher uniquement certaines colonnes, utilisez **SELECTCOLUMNS** :
   
   ```dax
   EVALUATE
   SELECTCOLUMNS(
    DimProduct,
    "Nom Produit", DimProduct[EnglishProductName],
    "Couleur", DimProduct[Color],
    "Prix", DimProduct[ListPrice]
   )
   ```

2. Notez que les noms de colonnes dans **SELECTCOLUMNS** sont entre guillemets

3. Cette requ√™te cr√©e une nouvelle table avec seulement 3 colonnes

---

## 2. Techniques de Filtrage et S√©lection

### 2.1 Niveau √âl√©mentaire

#### FILTER

La fonction **FILTER** retourne une table filtr√©e bas√©e sur une condition logique.

#### Walkthrough 2.1 : Filtrer les Produits Rouges

1. **Objectif** : afficher uniquement les produits de couleur rouge

2. Utilisez **FILTER** avec une condition :
   
   ```dax
   EVALUATE
   FILTER(
    DimProduct,
    DimProduct[Color] = "Red"
   )
   ```

3. **Syntaxe importante** : FILTER(*table*, *condition*)

4. La condition est √©valu√©e ligne par ligne dans le **contexte de ligne**

#### CALCULATE

La fonction **CALCULATE** √©value une expression dans un **contexte de filtre modifi√©**. C'est la fonction la plus puissante de DAX.

#### Walkthrough 2.2 : Ventes de Produits Rouges

1. Cr√©ez une mesure pour calculer les ventes de produits rouges uniquement :
   
   ```dax
   Ventes Produits Rouges = 
   CALCULATE(
    SUM(FactInternetSales[SalesAmount]),
    DimProduct[Color] = "Red"
   )
   ```

2. **Comprendre le m√©canisme** :
   
   - **CALCULATE** prend la mesure SUM(FactInternetSales[SalesAmount])
   - Elle applique un filtre suppl√©mentaire : Color = "Red"
   - Le filtre se propage via la relation entre DimProduct et FactInternetSales

3. Testez dans un visuel avec et sans filtre Color pour voir la diff√©rence

#### ALL, VALUES et DISTINCT

Ces trois fonctions manipulent les filtres de mani√®re diff√©rente :

- **ALL** : ignore tous les filtres et retourne toutes les lignes
- **VALUES** : retourne les valeurs distinctes visibles dans le contexte de filtre actuel
- **DISTINCT** : similaire √† VALUES mais n'inclut pas la ligne vide

#### Walkthrough 2.3 : Comprendre ALL vs VALUES

1. Cr√©ez deux mesures pour compter les produits :
   
   ```dax
   Nombre Total Produits = 
   COUNTROWS(ALL(DimProduct))
   ```

Nombre Produits Filtr√©s = 
COUNTROWS(VALUES(DimProduct[ProductKey]))

```
2. Placez ces mesures dans une matrice avec **DimProduct[Color]** en ligne
3. **Observation** :
   - "Nombre Total Produits" affiche toujours le m√™me nombre (total absolu)
   - "Nombre Produits Filtr√©s" varie selon la couleur (contexte respect√©)

#### ISCROSSFILTERED vs ISFILTERED

Ces fonctions testent si une colonne ou table est filtr√©e :

- **ISFILTERED** : TRUE si la colonne a un filtre **direct**
- **ISCROSSFILTERED** : TRUE si la colonne est filtr√©e directement **ou** indirectement via des relations

#### Walkthrough 2.4 : D√©tecter les Filtres

1. Cr√©ez cette mesure pour d√©tecter les filtres sur les produits :
```dax
Test Filtre Produit = 
IF(
    ISFILTERED(DimProduct[Color]),
    "Filtre DIRECT sur Color",
    IF(
        ISCROSSFILTERED(DimProduct[Color]),
        "Filtre INDIRECT sur Color",
        "Aucun filtre"
    )
)
```

2. Testez en ajoutant des filtres :
   - Sur DimProduct[Color] ‚Üí "Filtre DIRECT"
   - Sur DimProductCategory ‚Üí "Filtre INDIRECT" (via relations)
   - Sans filtre ‚Üí "Aucun filtre"

---

### 2.2 Niveau Interm√©diaire

#### ALL vs ALLEXCEPT vs ALLSELECTED

Ces variantes de ALL offrent un contr√¥le pr√©cis sur les filtres √† ignorer :

- **ALL(Table)** : ignore tous les filtres sur la table
- **ALLEXCEPT(Table, Colonne1, ...)** : ignore tous les filtres sauf ceux sur les colonnes sp√©cifi√©es
- **ALLSELECTED(Table)** : ignore les filtres de ligne/colonne mais garde les filtres du rapport

#### Walkthrough 2.5 : Part de March√© par Couleur

1. **Objectif** : calculer la part des ventes de chaque couleur par rapport au total

2. Cr√©ez d'abord une mesure de ventes totales :
   
   ```dax
   Ventes Totales = SUM(FactInternetSales[SalesAmount])
   ```

3. Cr√©ez la mesure de part avec **ALL** :
   
   ```dax
   % Ventes par Couleur = 
   DIVIDE(
    [Ventes Totales],
    CALCULATE(
        [Ventes Totales],
        ALL(DimProduct[Color])
    )
   )
   ```

4. **Explication** :
   
   - Le num√©rateur calcule les ventes pour la couleur actuelle (contexte de filtre)
   - Le d√©nominateur utilise **ALL(DimProduct[Color])** pour ignorer le filtre Color
   - R√©sultat : pourcentage de chaque couleur par rapport au total

5. Testez avec **ALLSELECTED** pour respecter les filtres du rapport :
   
   ```dax
   % Ventes S√©lectionn√©es = 
   DIVIDE(
    [Ventes Totales],
    CALCULATE(
        [Ventes Totales],
        ALLSELECTED(DimProduct[Color])
    )
   )
   ```

6. Ajoutez un segment (slicer) sur DimProduct[ProductLine] et observez la diff√©rence

#### Walkthrough 2.6 : ALLEXCEPT pour Sous-Totaux

1. Cr√©ez une mesure qui calcule les ventes par cat√©gorie, ignorant les filtres sur sous-cat√©gorie :
   
   ```dax
   Ventes par Cat√©gorie = 
   CALCULATE(
    [Ventes Totales],
    ALLEXCEPT(
        DimProduct,
        DimProductCategory[EnglishProductCategoryName]
    )
   )
   ```

2. Placez cette mesure dans une matrice avec Category et Subcategory

3. **R√©sultat attendu** : chaque ligne affiche le total de sa cat√©gorie, ind√©pendamment de la sous-cat√©gorie

#### SELECTEDVALUE vs SELECTCOLUMNS

- **SELECTEDVALUE** : retourne la valeur d'une colonne s'il n'y a qu'une seule valeur s√©lectionn√©e
- **SELECTCOLUMNS** : cr√©e une table avec des colonnes personnalis√©es

#### Walkthrough 2.7 : Afficher la S√©lection

1. Cr√©ez une mesure qui affiche la couleur s√©lectionn√©e :
   
   ```dax
   Couleur S√©lectionn√©e = 
   SELECTEDVALUE(
    DimProduct[Color],
    "Plusieurs couleurs"
   )
   ```

2. **Comportement** :
   
   - Si une seule couleur est filtr√©e ‚Üí affiche cette couleur
   - Si plusieurs couleurs ou aucun filtre ‚Üí affiche "Plusieurs couleurs"

3. Pour **SELECTCOLUMNS**, cr√©ez une table personnalis√©e dans DAX Studio :
   
   ```dax
   EVALUATE
   SELECTCOLUMNS(
    DimProduct,
    "Nom", DimProduct[EnglishProductName],
    "Prix HT", DimProduct[ListPrice],
    "Prix TTC", DimProduct[ListPrice] * 1.2
   )
   ```

4. **Point cl√©** : SELECTCOLUMNS peut cr√©er des colonnes calcul√©es √† la vol√©e

#### TOPN

La fonction **TOPN** retourne les N premi√®res lignes d'une table selon un crit√®re de tri.

#### Walkthrough 2.8 : Top 5 Produits

1. Cr√©ez une mesure qui affiche les ventes du top 5 des produits :
   
   ```dax
   Ventes Top 5 Produits = 
   CALCULATE(
    [Ventes Totales],
    TOPN(
        5,
        ALL(DimProduct[EnglishProductName]),
        [Ventes Totales],
        DESC
    )
   )
   ```

2. **Syntaxe** : TOPN(*N*, *Table*, *Orderby_Expression*, *[Order]*)

3. Testez dans une matrice pour voir uniquement les 5 meilleurs produits

---

### 2.3 Niveau Avanc√©

#### CROSSFILTER et USERELATIONSHIP

Ces fonctions contr√¥lent les relations entre tables :

- **USERELATIONSHIP** : active une relation inactive temporairement
- **CROSSFILTER** : modifie la direction de filtrage d'une relation

#### Walkthrough 2.9 : Ventes par Date d'Exp√©dition

1. **Contexte** : Le mod√®le a 3 relations entre FactInternetSales et DimDate :
   
   - OrderDateKey ‚Üí DateKey (**active**)
   - ShipDateKey ‚Üí DateKey (**inactive**)
   - DueDateKey ‚Üí DateKey (**inactive**)

2. Cr√©ez une mesure pour les ventes par date d'exp√©dition :
   
   ```dax
   Ventes par Date Exp√©dition = 
   CALCULATE(
    [Ventes Totales],
    USERELATIONSHIP(
        FactInternetSales[ShipDateKey],
        DimDate[DateKey]
    )
   )
   ```

3. **R√©sultat** : Cette mesure utilise la date d'exp√©dition au lieu de la date de commande

4. Comparez les deux mesures dans un graphique par mois pour voir le d√©calage temporel

#### KEEPFILTERS

Par d√©faut, **CALCULATE** **remplace** les filtres existants. **KEEPFILTERS** force l'**intersection** des filtres.

#### Walkthrough 2.10 : Intersection de Filtres

1. Cr√©ez deux mesures pour comparer le comportement :
   
   ```dax
   Ventes Rouges (Sans KEEPFILTERS) = 
   CALCULATE(
    [Ventes Totales],
    DimProduct[Color] = "Red"
   )
   ```

Ventes Rouges (Avec KEEPFILTERS) = 
CALCULATE(
    [Ventes Totales],
    KEEPFILTERS(DimProduct[Color] = "Red")
)

```
2. Testez avec un segment sur Color = "Black" :
   - **Sans KEEPFILTERS** : affiche les ventes rouges (ignore le segment Black)
   - **Avec KEEPFILTERS** : affiche 0 (intersection de Red et Black = vide)

#### CALCULATE + FILTER

Combiner **CALCULATE** et **FILTER** permet des filtres complexes bas√©s sur des mesures.

#### Walkthrough 2.11 : Produits √† Forte Valeur

1. **Objectif** : calculer les ventes des produits dont le prix de liste > $1000
2. Cr√©ez cette mesure :
```dax
Ventes Produits Premium = 
CALCULATE(
    [Ventes Totales],
    FILTER(
        ALL(DimProduct),
        DimProduct[ListPrice] > 1000
    )
)
```

3. **Explication d√©taill√©e** :
   
   - **ALL(DimProduct)** ignore d'abord tous les filtres sur DimProduct
   - **FILTER** applique ensuite la condition ListPrice > 1000
   - **CALCULATE** √©value les ventes avec ce nouveau filtre

4. Comparez avec une mesure standard pour voir la diff√©rence de montant

#### FILTER + RELATEDTABLE

**RELATEDTABLE** retourne toutes les lignes d'une table de faits li√©es √† la ligne actuelle d'une table de dimension.

#### Walkthrough 2.12 : Clients avec Plus de 10 Commandes

1. Cr√©ez une mesure qui compte les clients ayant plus de 10 commandes :
   
   ```dax
   Clients Fid√®les = 
   COUNTROWS(
    FILTER(
        ALL(DimCustomer),
        COUNTROWS(
            RELATEDTABLE(FactInternetSales)
        ) > 10
    )
   )
   ```

2. **M√©canisme** :
   
   - Pour chaque client dans DimCustomer
   - **RELATEDTABLE** r√©cup√®re toutes ses lignes de ventes
   - **COUNTROWS** compte ces lignes
   - **FILTER** garde uniquement les clients avec > 10 commandes

---

### 2.4 Filtrage de Tables : CALCULATETABLE, SUMMARIZE et GROUPBY

#### CALCULATETABLE

**CALCULATETABLE** est l'√©quivalent de **CALCULATE** mais retourne une table au lieu d'une valeur scalaire.

#### Walkthrough 2.13 : Table Filtr√©e de Produits

1. Utilisez CALCULATETABLE dans une requ√™te EVALUATE :
   
   ```dax
   EVALUATE
   CALCULATETABLE(
    SELECTCOLUMNS(
        DimProduct,
        "Produit", DimProduct[EnglishProductName],
        "Prix", DimProduct[ListPrice]
    ),
    DimProduct[Color] = "Red",
    DimProduct[ListPrice] > 500
   )
   ```

2. **R√©sultat** : Table des produits rouges avec prix > 500

#### SUMMARIZE

**SUMMARIZE** cr√©e une table agr√©g√©e en groupant par colonnes sp√©cifi√©es.

#### Walkthrough 2.14 : R√©sum√© des Ventes par Cat√©gorie

1. Cr√©ez un r√©sum√© avec cat√©gorie et total des ventes :
   
   ```dax
   EVALUATE
   ADDCOLUMNS(
    SUMMARIZE(
        FactInternetSales,
        DimProductCategory[EnglishProductCategoryName]
    ),
    "Total Ventes",
    CALCULATE(SUM(FactInternetSales[SalesAmount]))
   )
   ```

2. **Important** : SUMMARIZE seul ne calcule pas d'agr√©gations, il groupe seulement

3. Utilisez **ADDCOLUMNS** pour ajouter des calculs au r√©sum√©

#### GROUPBY

**GROUPBY** est similaire √† SUMMARIZE mais permet des agr√©gations int√©gr√©es et offre de meilleures performances.

#### Walkthrough 2.15 : Comparaison SUMMARIZE vs GROUPBY

1. Avec **GROUPBY**, les agr√©gations sont d√©finies directement :
   
   ```dax
   EVALUATE
   GROUPBY(
    FactInternetSales,
    DimProductCategory[EnglishProductCategoryName],
    DimProduct[Color],
    "Total Ventes",
    SUMX(CURRENTGROUP(), FactInternetSales[SalesAmount]),
    "Nombre Commandes",
    COUNTX(CURRENTGROUP(), FactInternetSales[SalesOrderNumber])
   )
   ```

2. **Avantage** : GROUPBY est plus performant car il utilise **CURRENTGROUP()** pour r√©f√©rencer le groupe actuel

3. **CURRENTGROUP()** retourne toutes les lignes du groupe en cours d'√©valuation

---

## 3. Simulation de Jointure

### ADDCOLUMNS + RELATED

**RELATED** permet d'acc√©der aux colonnes d'une table li√©e (c√¥t√© "un" de la relation).

#### Walkthrough 3.1 : Enrichir les Ventes avec les Informations Client

1. Cr√©ez une table enrichie avec les donn√©es client :
   
   ```dax
   EVALUATE
   ADDCOLUMNS(
    TOPN(100, FactInternetSales),
    "Nom Client", RELATED(DimCustomer[FirstName]) & " " & RELATED(DimCustomer[LastName]),
    "Ville", RELATED(DimGeography[City]),
    "Pays", RELATED(DimGeography[EnglishCountryRegionName])
   )
   ```

2. **Point cl√©** : **RELATED** suit la cha√Æne de relations (FactInternetSales ‚Üí DimCustomer ‚Üí DimGeography)

3. Cette approche simule un **LEFT JOIN** SQL

### SUMMARIZECOLUMNS

**SUMMARIZECOLUMNS** combine agr√©gation et jointure en une seule fonction.

#### Walkthrough 3.2 : Agr√©gation Multi-Tables

1. Cr√©ez un r√©sum√© avec colonnes de plusieurs tables :
   
   ```dax
   EVALUATE
   SUMMARIZECOLUMNS(
    DimProductCategory[EnglishProductCategoryName],
    DimProduct[Color],
    DimDate[CalendarYear],
    "Total Ventes", SUM(FactInternetSales[SalesAmount]),
    "Quantit√© Totale", SUM(FactInternetSales[OrderQuantity]),
    "Nombre Commandes", DISTINCTCOUNT(FactInternetSales[SalesOrderNumber])
   )
   ```

2. **Avantage** : SUMMARIZECOLUMNS g√®re automatiquement les jointures via les relations

3. C'est la m√©thode recommand√©e pour cr√©er des tables d'agr√©gation complexes

### GENERATE (Jointure Conditionnelle - LEFT JOIN)

**GENERATE** cr√©e un produit cart√©sien entre deux tables, similaire √† un CROSS JOIN suivi d'un LEFT JOIN.

#### Walkthrough 3.3 : Produits avec leurs Cat√©gories

1. Utilisez GENERATE pour joindre tables :
   
   ```dax
   EVALUATE
   GENERATE(
    TOPN(10, DimProductCategory),
    CALCULATETABLE(
        SELECTCOLUMNS(
            DimProduct,
            "Produit", DimProduct[EnglishProductName],
            "Prix", DimProduct[ListPrice]
        ),
        FILTER(
            DimProduct,
            DimProduct[ProductSubcategoryKey] IN 
            VALUES(DimProductSubcategory[ProductSubcategoryKey])
        )
    )
   )
   ```

2. **M√©canisme** :
   
   - GENERATE it√®re sur chaque cat√©gorie
   - Pour chaque cat√©gorie, CALCULATETABLE r√©cup√®re les produits associ√©s
   - Le r√©sultat combine les colonnes des deux tables

### FILTER + CROSSJOIN

**CROSSJOIN** cr√©e un produit cart√©sien complet entre tables.

#### Walkthrough 3.4 : Combinaisons Produit-Couleur

1. Cr√©ez toutes les combinaisons possibles :
   
   ```dax
   EVALUATE
   FILTER(
    CROSSJOIN(
        VALUES(DimProduct[EnglishProductName]),
        VALUES(DimProduct[Color])
    ),
    NOT(ISBLANK([Color]))
   )
   ```

2. **Attention** : CROSSJOIN peut cr√©er des tables tr√®s larges. Utilisez FILTER pour limiter les r√©sultats

3. **Cas d'usage** : G√©n√©rer des sc√©narios de test ou des matrices de configuration

### UNION

**UNION** combine les lignes de plusieurs tables.

#### Walkthrough 3.5 : Consolider Plusieurs Segments

1. Combinez diff√©rents sous-ensembles de donn√©es :
   
   ```dax
   EVALUATE
   UNION(
    SELECTCOLUMNS(
        FILTER(DimProduct, DimProduct[Color] = "Red"),
        "Type", "Produit Rouge",
        "Nom", DimProduct[EnglishProductName],
        "Valeur", DimProduct[ListPrice]
    ),
    SELECTCOLUMNS(
        FILTER(DimProduct, DimProduct[ListPrice] > 2000),
        "Type", "Produit Premium",
        "Nom", DimProduct[EnglishProductName],
        "Valeur", DimProduct[ListPrice]
    )
   )
   ```

2. **Important** : Les tables doivent avoir le m√™me nombre de colonnes et des types compatibles

3. **Cas d'usage** : Cr√©er des listes consolid√©es de diff√©rentes sources

### FILTER + EARLIER (SELF JOIN)

**EARLIER** permet de r√©f√©rencer le contexte de ligne externe dans des filtres imbriqu√©s.

#### Walkthrough 3.6 : Produits Plus Chers que la Moyenne de leur Cat√©gorie

1. Cr√©ez une requ√™te avec auto-jointure :
   
   ```dax
   EVALUATE
   FILTER(
    DimProduct,
    DimProduct[ListPrice] > 
    CALCULATE(
        AVERAGE(DimProduct[ListPrice]),
        FILTER(
            ALL(DimProduct),
            DimProduct[ProductSubcategoryKey] = EARLIER(DimProduct[ProductSubcategoryKey])
        )
    )
   )
   ```

2. **Explication d√©taill√©e** :
   
   - Pour chaque produit (contexte externe)
   - **EARLIER** capture sa ProductSubcategoryKey
   - **FILTER** s√©lectionne tous les produits de la m√™me sous-cat√©gorie
   - **CALCULATE** calcule la moyenne de cette sous-cat√©gorie
   - Garde uniquement les produits au-dessus de cette moyenne

3. **Alternative moderne** : Utilisez des variables pour plus de clart√© :
   
   ```dax
   EVALUATE
   FILTER(
    DimProduct,
    VAR CurrentSubcategory = DimProduct[ProductSubcategoryKey]
    VAR AvgPrice = 
        CALCULATE(
            AVERAGE(DimProduct[ListPrice]),
            FILTER(
                ALL(DimProduct),
                DimProduct[ProductSubcategoryKey] = CurrentSubcategory
            )
        )
    RETURN
        DimProduct[ListPrice] > AvgPrice
   )
   ```

---

## 4. Sc√©nario 3 : Comparaison SUM vs SUMX

### Comprendre les Agr√©gations vs AggregationsX

La diff√©rence fondamentale :

- **SUM** : agr√®ge une colonne directement
- **SUMX** : it√®re sur une table, √©value une expression pour chaque ligne, puis agr√®ge

#### Walkthrough 4.1 : SUM - Agr√©gation Simple

1. Cr√©ez une mesure avec SUM :
   
   ```dax
   Total Ventes (SUM) = SUM(FactInternetSales[SalesAmount])
   ```

2. **M√©canisme** :
   
   - Additionne directement la colonne SalesAmount
   - Rapide et efficace pour des colonnes existantes
   - Fonctionne dans le contexte de filtre actuel

#### Walkthrough 4.2 : SUMX - Calcul Ligne par Ligne

1. **Sc√©nario** : Calculer le montant avec une remise de 10% appliqu√©e √† chaque vente
   
   ```dax
   Total Ventes avec Remise (SUMX) = 
   SUMX(
    FactInternetSales,
    FactInternetSales[SalesAmount] * 0.9
   )
   ```

2. **M√©canisme** :
   
   - It√®re sur chaque ligne de FactInternetSales
   - Calcule SalesAmount * 0.9 pour chaque ligne
   - Additionne tous les r√©sultats

3. **Point critique** : On ne peut pas simplement faire `SUM(...) * 0.9` car cela appliquerait la remise au total, pas ligne par ligne

#### Walkthrough 4.3 : Cas Complexe - Marge B√©n√©ficiaire

1. Cr√©ez une mesure qui calcule la marge (impossible avec SUM seul) :
   
   ```dax
   Marge Totale = 
   SUMX(
    FactInternetSales,
    FactInternetSales[SalesAmount] - FactInternetSales[TotalProductCost]
   )
   ```

2. **Pourquoi SUMX ?** 
   
   - Il faut soustraire ligne par ligne
   - `SUM(SalesAmount) - SUM(TotalProductCost)` donnerait le m√™me r√©sultat ici
   - Mais pour des calculs plus complexes (multiplications, divisions), SUMX est indispensable

#### Walkthrough 4.4 : Exemple D√©terminant - Prix Moyen Pond√©r√©

1. **Objectif** : Calculer le prix unitaire moyen pond√©r√© par la quantit√©
   
   ```dax
   Prix Moyen Pond√©r√© (INCORRECT) = 
   AVERAGE(FactInternetSales[UnitPrice])
   ```

Prix Moyen Pond√©r√© (CORRECT) = 
DIVIDE(
    SUMX(
        FactInternetSales,
        FactInternetSales[UnitPrice] * FactInternetSales[OrderQuantity]
    ),
    SUM(FactInternetSales[OrderQuantity])
)

```
2. **D√©monstration de la diff√©rence** :
   - Vente 1 : 10 unit√©s √† 100‚Ç¨ = 1000‚Ç¨
   - Vente 2 : 1 unit√© √† 200‚Ç¨ = 200‚Ç¨

   - AVERAGE : (100 + 200) / 2 = **150‚Ç¨** ‚ùå
   - Prix pond√©r√© : (10√ó100 + 1√ó200) / (10 + 1) = **109‚Ç¨** ‚úÖ

3. **Conclusion** : AVERAGE ignore les quantit√©s, SUMX permet de les prendre en compte

#### Walkthrough 4.5 : Performance - Quand Utiliser Quoi ?

1. **Utilisez SUM quand** :
   - Vous agr√©gez une colonne existante sans transformation
   - Exemple : `SUM(FactInternetSales[SalesAmount])`

2. **Utilisez SUMX quand** :
   - Vous devez calculer quelque chose ligne par ligne
   - Vous multipliez, divisez ou combinez plusieurs colonnes
   - Exemple : `SUMX(Table, [Col1] * [Col2])`

3. **Test de performance** :
```dax
// Plus rapide
Mesure Rapide = SUM(FactInternetSales[SalesAmount])

// Plus lent (inutilement)
Mesure Lente = 
SUMX(
    FactInternetSales,
    FactInternetSales[SalesAmount]
)
```

4. **R√®gle d'or** : Utilisez toujours la fonction la plus simple qui r√©sout votre probl√®me

#### Tableau R√©capitulatif

| Fonction     | Usage                 | Quand l'utiliser                     | Performance  |
| ------------ | --------------------- | ------------------------------------ | ------------ |
| **SUM**      | Agr√®ge une colonne    | Somme simple d'une colonne existante | ‚ö° Rapide     |
| **SUMX**     | It√®re et calcule      | Calculs complexes ligne par ligne    | üê¢ Plus lent |
| **AVERAGE**  | Moyenne simple        | Moyenne arithm√©tique                 | ‚ö° Rapide     |
| **AVERAGEX** | Moyenne calcul√©e      | Moyenne pond√©r√©e ou avec formule     | üê¢ Plus lent |
| **COUNT**    | Compte les valeurs    | Nombre de lignes non vides           | ‚ö° Rapide     |
| **COUNTX**   | Compte avec condition | Comptage conditionnel complexe       | üê¢ Plus lent |

---

## Conclusion

Cet atelier a couvert les fondamentaux essentiels de DAX :

‚úÖ **EVALUATE** pour tester vos requ√™tes  
‚úÖ **Filtrage** avec FILTER, CALCULATE, ALL, VALUES  
‚úÖ **Contr√¥le avanc√©** avec KEEPFILTERS, USERELATIONSHIP, CROSSFILTER  
‚úÖ **Agr√©gation** avec SUMMARIZE, GROUPBY, CALCULATETABLE  
‚úÖ **Jointures** simul√©es avec RELATED, GENERATE, UNION  
‚úÖ **Diff√©rence critique** entre agr√©gations simples (SUM) et it√©ratives (SUMX)

### Prochaines √âtapes

1. **Pratiquez** chaque walkthrough dans votre environnement
2. **Exp√©rimentez** avec vos propres variations
3. **Comparez** les performances de diff√©rentes approches
4. **Approfondissez** avec les fonctions de Time Intelligence (prochaine session)

### Ressources Compl√©mentaires

- Documentation officielle DAX : [dax.guide](https://dax.guide)
- DAX Studio : outil gratuit pour tester vos requ√™tes
- SQLBI : formation avanc√©e et patterns DAX


