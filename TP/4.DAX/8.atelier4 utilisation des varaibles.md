# Atelier 4 : Variables, Contextes et Optimisation

## AdventureWorksDW2022 - Techniques Avancées DAX

---

## Introduction

Cet atelier explore les concepts avancés de DAX qui séparent les utilisateurs intermédiaires des experts. Vous apprendrez à maîtriser les **variables**, comprendre en profondeur les **contextes d'évaluation**, et optimiser les performances de vos mesures.

### Prérequis

Avant de commencer cet atelier, assurez-vous d'avoir :

- Complété les Ateliers 1, 2 et 3
- Une excellente compréhension de CALCULATE et des filtres
- Une connaissance des relations et de la Time Intelligence
- Le modèle AdventureWorksDW2022 complètement chargé

### Objectifs de l'Atelier

À la fin de cet atelier, vous serez capable de :

- Utiliser les variables (VAR/RETURN) pour des calculs complexes et performants
- Comprendre et manipuler le contexte de ligne vs contexte de filtre
- Maîtriser la transition de contexte (context transition)
- Identifier et résoudre les problèmes de performance
- Écrire des mesures DAX optimisées et maintenables

### Architecture Conceptuelle

**Les Deux Contextes DAX** :

┌─────────────────────────────────────────┐
│ CONTEXTE DE FILTRE │
│ (Filter Context) │
│ - Appliqué par les visuels │
│ - Modifié par CALCULATE │
│ - Se propage via les relations │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ CONTEXTE DE LIGNE │
│ (Row Context) │
│ - Créé par les fonctions X │
│ - Créé par les colonnes calculées │
│ - NE se propage PAS automatiquement │
└─────────────────────────────────────────┘

## Partie 1 : Maîtriser les Variables (VAR/RETURN)

### 1.1 Fondamentaux des Variables

Les variables DAX permettent de :

- **Stocker** des résultats intermédiaires
- **Améliorer** la lisibilité du code
- **Optimiser** les performances (calcul une seule fois)
- **Faciliter** le débogage

#### Syntaxe de Base


=

VAR = 
VAR = 
RETURN

### Walkthrough 1.1 : Première Variable Simple

1. **Sans variable (approche répétitive)** :

```dax
Marge Brute (Sans VAR) = 
DIVIDE(
    SUM(FactInternetSales[SalesAmount]) - SUM(FactInternetSales[TotalProductCost]),
    SUM(FactInternetSales[SalesAmount])
)
```

2. **Avec variables (approche optimisée)** :

```dax
Marge Brute (Avec VAR) = 
VAR TotalSales = SUM(FactInternetSales[SalesAmount])
VAR TotalCost = SUM(FactInternetSales[TotalProductCost])
VAR GrossProfit = TotalSales - TotalCost
RETURN
    DIVIDE(GrossProfit, TotalSales)
```

3. **Avantages** :
   
   - ✅ Plus lisible (noms explicites)
   - ✅ Plus performant (SUM calculé une seule fois)
   - ✅ Plus facile à déboguer (peut tester chaque variable)
   - ✅ Plus maintenable (modification en un seul endroit)

4. **⚠️ Important** : Les variables sont **immuables** (ne peuvent pas être modifiées après création)

```dax
// ❌ ERREUR - impossible de réassigner
VAR Total = 100
VAR Total = Total + 50  // Erreur de syntaxe

// ✅ CORRECT - créer une nouvelle variable
VAR Total = 100
VAR NewTotal = Total + 50
RETURN NewTotal
```

### Walkthrough 1.2 : Variables et Contexte de Filtre

1. **Point critique** : Les variables **capturent** le contexte de filtre au moment de leur déclaration

```dax
Test Contexte Variables = 
VAR AllSales = SUM(FactInternetSales[SalesAmount])  -- Contexte actuel
RETURN
    CALCULATE(
        AllSales,  -- Cette valeur ne change PAS
        ALL(DimProduct)  -- Ce filtre n'affecte PAS AllSales
    )
```

2. **Explication détaillée** :
   
   - **AllSales** capture les ventes dans le contexte actuel
   - **CALCULATE** modifie le contexte de filtre
   - Mais **AllSales** conserve sa valeur originale (déjà calculée)
   - Le ALL(DimProduct) n'a aucun effet sur AllSales

3. **Version correcte** :

```dax
Ventes Tous Produits (Correct) = 
CALCULATE(
    SUM(FactInternetSales[SalesAmount]),
    ALL(DimProduct)
)
```

4. **Cas d'usage des variables avec CALCULATE** :

```dax
Part de Marché Produit = 
VAR VentesProduit = SUM(FactInternetSales[SalesAmount])  -- Contexte avec filtre produit
VAR VentesTotales = CALCULATE(
    SUM(FactInternetSales[SalesAmount]),
    ALL(DimProduct)  -- Contexte sans filtre produit
)
RETURN
    DIVIDE(VentesProduit, VentesTotales)
```

### Walkthrough 1.3 : Variables pour Calculs Complexes

1. **Scénario** : Calculer un score de performance composite

```dax
Score Performance Client = 
VAR FrequenceAchats = COUNTROWS(RELATEDTABLE(FactInternetSales))
VAR MontantMoyen = AVERAGE(FactInternetSales[SalesAmount])
VAR AncienneteJours = DATEDIFF(MIN(FactInternetSales[OrderDate]), TODAY(), DAY)
VAR AncienneteAnnees = DIVIDE(AncienneteJours, 365)

-- Normalisation sur échelle 0-100
VAR ScoreFrequence = MIN(DIVIDE(FrequenceAchats, 50) * 40, 40)  -- Max 40 points
VAR ScoreMontant = MIN(DIVIDE(MontantMoyen, 1000) * 30, 30)     -- Max 30 points  
VAR ScoreAnciennete = MIN(AncienneteAnnees * 10, 30)            -- Max 30 points

VAR ScoreTotal = ScoreFrequence + ScoreMontant + ScoreAnciennete

RETURN
    ScoreTotal
```

2. **Avantages de cette structure** :
   
   - Chaque composante est clairement identifiée
   - Facile de modifier les pondérations
   - Peut être testé étape par étape
   - Auto-documenté par les noms de variables

3. **Testez** : Créez une matrice avec CustomerKey et ce score

### Walkthrough 1.4 : Variables pour Éviter les Calculs Répétitifs

1. **Problème de performance** :

```dax
// ❌ MAUVAIS - CALCULATE appelé 3 fois
Indicateur Performance (Lent) = 
IF(
    CALCULATE([Ventes Totales], ALL(DimProduct)) > 1000000,
    IF(
        CALCULATE([Ventes Totales], ALL(DimProduct)) > 5000000,
        "Excellent",
        "Bon"
    ),
    IF(
        CALCULATE([Ventes Totales], ALL(DimProduct)) > 500000,
        "Moyen",
        "Faible"
    )
)
```

2. **Solution avec variable** :

```dax
// ✅ BON - CALCULATE appelé 1 seule fois
Indicateur Performance (Rapide) = 
VAR VentesTotales = CALCULATE([Ventes Totales], ALL(DimProduct))
RETURN
    SWITCH(
        TRUE(),
        VentesTotales > 5000000, "Excellent",
        VentesTotales > 1000000, "Bon",
        VentesTotales > 500000, "Moyen",
        "Faible"
    )
```

3. **Gain de performance** : 3x plus rapide (1 calcul au lieu de 3+)

### Walkthrough 1.5 : Variables pour Tables Virtuelles

1. **Les variables peuvent stocker des tables** :

```dax
Top 10 Produits Ventes = 
VAR TopProducts = 
    TOPN(
        10,
        ALL(DimProduct[EnglishProductName]),
        [Ventes Totales],
        DESC
    )
VAR TopProductSales = 
    CALCULATE(
        [Ventes Totales],
        TopProducts
    )
RETURN
    TopProductSales
```

2. **Table virtuelle avec plusieurs colonnes** :

```dax
Analyse Clients = 
VAR CustomerAnalysis = 
    ADDCOLUMNS(
        VALUES(DimCustomer[CustomerKey]),
        "TotalSales", [Ventes Totales],
        "OrderCount", COUNTROWS(RELATEDTABLE(FactInternetSales)),
        "AvgOrderValue", DIVIDE([Ventes Totales], COUNTROWS(RELATEDTABLE(FactInternetSales)))
    )
VAR HighValueCustomers = 
    FILTER(
        CustomerAnalysis,
        [TotalSales] > 5000
    )
RETURN
    COUNTROWS(HighValueCustomers)
```

3. **⚠️ Important** : Les tables dans les variables sont matérialisées en mémoire
   - Avantage : Réutilisation sans recalcul
   - Inconvénient : Consomme de la RAM si très grandes

### Walkthrough 1.6 : Débogage avec Variables

1. **Technique de débogage** : Retourner des variables intermédiaires

```dax
Debug Score Performance = 
VAR FrequenceAchats = COUNTROWS(RELATEDTABLE(FactInternetSales))
VAR MontantMoyen = AVERAGE(FactInternetSales[SalesAmount])
VAR ScoreFrequence = MIN(DIVIDE(FrequenceAchats, 50) * 40, 40)
VAR ScoreMontant = MIN(DIVIDE(MontantMoyen, 1000) * 30, 30)

-- Pour déboguer, retourner une variable spécifique
RETURN
    FrequenceAchats  -- Temporairement, pour voir cette valeur
    -- ScoreFrequence  -- Ou celle-ci
    -- ScoreMontant  -- Ou celle-là
```

2. **Table de debug complète** :

```dax
Debug Table = 
VAR FrequenceAchats = COUNTROWS(RELATEDTABLE(FactInternetSales))
VAR MontantMoyen = AVERAGE(FactInternetSales[SalesAmount])
VAR ScoreFrequence = MIN(DIVIDE(FrequenceAchats, 50) * 40, 40)
RETURN
    -- Retourne une table avec toutes les valeurs
    {
        ("Frequence", FrequenceAchats),
        ("Montant Moyen", MontantMoyen),
        ("Score Freq", ScoreFrequence)
    }
```

### Bonnes Pratiques - Variables

✅ **À FAIRE** :

- Utiliser des noms de variables descriptifs (pas x, y, z)
- Déclarer les variables dans l'ordre logique de calcul
- Utiliser des variables pour tout calcul utilisé 2+ fois
- Commenter les variables complexes

❌ **À ÉVITER** :

- Créer trop de variables inutiles (surcharge cognitive)
- Utiliser des variables pour des valeurs triviales
- Nommer les variables avec des acronymes obscurs
- Oublier que les variables capturent le contexte au moment de la déclaration

---

## Partie 2 : Contextes d'Évaluation - Profondeur

### 2.1 Contexte de Filtre (Filter Context)

Le **contexte de filtre** est l'ensemble des filtres actifs qui déterminent quelles lignes sont visibles.

### Walkthrough 2.1 : Visualiser le Contexte de Filtre

1. **Sources de contexte de filtre** :

```dax
Contexte de Filtre Info = 
VAR IsYearFiltered = ISFILTERED(DimDate[CalendarYear])
VAR IsProductFiltered = ISFILTERED(DimProduct[Color])
VAR IsCrossFiltered = ISCROSSFILTERED(DimProduct[Color])
RETURN
    "Year: " & IF(IsYearFiltered, "Filtré", "Non filtré") & " | " &
    "Color Direct: " & IF(IsProductFiltered, "Filtré", "Non filtré") & " | " &
    "Color Cross: " & IF(IsCrossFiltered, "Filtré", "Non filtré")
```

2. **Testez** :
   
   - Sans filtre → Tout "Non filtré"
   - Ajoutez segment sur CalendarYear → "Year: Filtré"
   - Ajoutez segment sur ProductCategory → "Color Cross: Filtré" (relation indirecte)
   - Ajoutez segment sur Color → "Color Direct: Filtré"

3. **Propagation du contexte via relations** :

```dax
Ventes avec Propagation = 
VAR FilterOnCategory = ISFILTERED(DimProductCategory[EnglishProductCategoryName])
VAR FilterOnProduct = ISCROSSFILTERED(DimProduct[ProductKey])
RETURN
    "Catégorie filtrée: " & FilterOnCategory & " → " &
    "Produit cross-filtré: " & FilterOnProduct
```

4. **Résultat** : Filtrer sur Category filtre automatiquement Product via les relations

### Walkthrough 2.2 : Modification du Contexte de Filtre

1. **CALCULATE modifie le contexte de filtre** :

```dax
Demo CALCULATE = 
VAR VentesContexteActuel = SUM(FactInternetSales[SalesAmount])
VAR VentesSansFiltreProduit = 
    CALCULATE(
        SUM(FactInternetSales[SalesAmount]),
        ALL(DimProduct)
    )
VAR VentesAvecFiltre2013 = 
    CALCULATE(
        SUM(FactInternetSales[SalesAmount]),
        DimDate[CalendarYear] = 2013
    )
RETURN
    "Actuel: " & VentesContexteActuel & " | " &
    "Sans Produit: " & VentesSansFiltreProduit & " | " &
    "2013 Only: " & VentesAvecFiltre2013
```

2. **Testez** avec différents filtres et observez les changements

3. **Ordre d'application des filtres dans CALCULATE** :

```dax
Test Ordre Filtres = 
-- Les filtres sont appliqués dans l'ordre
CALCULATE(
    SUM(FactInternetSales[SalesAmount]),
    DimDate[CalendarYear] = 2013,      -- 1. Filtre sur 2013
    DimProduct[Color] = "Red",          -- 2. Ajoute filtre Red
    ALL(DimProduct[Color])              -- 3. ANNULE le filtre Red
)
-- Résultat: Toutes les couleurs de 2013
```

4. **⚠️ Important** : Le dernier filtre sur une colonne gagne

### 2.2 Contexte de Ligne (Row Context)

Le **contexte de ligne** est créé quand une formule itère sur une table, ligne par ligne.

### Walkthrough 2.3 : Comprendre le Contexte de Ligne

1. **Les fonctions X créent un contexte de ligne** :

```dax
// SUMX itère sur chaque ligne de FactInternetSales
Marge Totale = 
SUMX(
    FactInternetSales,
    FactInternetSales[SalesAmount] - FactInternetSales[TotalProductCost]
    -- ↑ Contexte de LIGNE : accède aux colonnes de la ligne actuelle
)
```

2. **Colonnes calculées ont toujours un contexte de ligne** :

```dax
// Dans DimProduct (colonne calculée)
Marge Produit = 
DimProduct[ListPrice] - DimProduct[StandardCost]
-- ↑ Contexte de LIGNE automatique
```

3. **⚠️ Piège** : Contexte de ligne ne se propage PAS via les relations

```dax
// ❌ Dans FactInternetSales (colonne calculée) - NE FONCTIONNE PAS
Nom Produit (Erreur) = 
DimProduct[EnglishProductName]
-- Erreur: plusieurs valeurs possibles

// ✅ SOLUTION : Utiliser RELATED
Nom Produit (Correct) = 
RELATED(DimProduct[EnglishProductName])
```

### Walkthrough 2.4 : Contexte de Ligne Imbriqué

1. **Plusieurs niveaux d'itération** :

```dax
Analyse Multi-Niveaux = 
SUMX(
    VALUES(DimProductCategory[ProductCategoryKey]),  -- Niveau 1
    VAR CategoryKey = DimProductCategory[ProductCategoryKey]
    RETURN
        SUMX(
            FILTER(
                DimProduct,
                DimProduct[ProductSubcategoryKey] IN 
                    CALCULATETABLE(
                        VALUES(DimProductSubcategory[ProductSubcategoryKey]),
                        DimProductSubcategory[ProductCategoryKey] = CategoryKey
                    )
            ),  -- Niveau 2
            VAR ProductKey = DimProduct[ProductKey]
            RETURN
                CALCULATE(
                    SUM(FactInternetSales[SalesAmount]),
                    FactInternetSales[ProductKey] = ProductKey
                )
        )
)
```

2. **Plus simple avec variables pour capturer le contexte** :

```dax
Ventes par Catégorie (Simplifié) = 
SUMX(
    VALUES(DimProductCategory[ProductCategoryKey]),
    VAR CurrentCategory = DimProductCategory[ProductCategoryKey]
    VAR CategoryProducts = 
        CALCULATETABLE(
            VALUES(DimProduct[ProductKey]),
            RELATEDTABLE(DimProductSubcategory),
            DimProductSubcategory[ProductCategoryKey] = CurrentCategory
        )
    RETURN
        CALCULATE(
            [Ventes Totales],
            CategoryProducts
        )
)
```

### 2.3 Transition de Contexte (Context Transition)

La **transition de contexte** transforme automatiquement un contexte de ligne en contexte de filtre.

### Walkthrough 2.5 : Découvrir la Transition de Contexte

1. **Sans transition de contexte** :

```dax
// Colonne calculée dans DimProduct
Ventes Produit (Sans Transition) = 
SUM(FactInternetSales[SalesAmount])
-- ❌ Retourne les ventes TOTALES (contexte de ligne ignoré)
```

2. **Avec transition de contexte** :

```dax
// Colonne calculée dans DimProduct
Ventes Produit (Avec Transition) = 
CALCULATE(SUM(FactInternetSales[SalesAmount]))
-- ✅ CALCULATE déclenche la transition de contexte
-- Le contexte de ligne (ProductKey actuel) devient un filtre
```

3. **Explication détaillée** :
   
   - **Sans CALCULATE** : SUM voit tout FactInternetSales (contexte de filtre du rapport)
   - **Avec CALCULATE** :
     1. Contexte de ligne : ProductKey = 123
     2. Transition → Filtre : ProductKey = 123
     3. SUM voit uniquement les ventes du produit 123

4. **Visualisation** :

```
Contexte de Ligne                Transition                Contexte de Filtre
─────────────────       ──────────────────────>      ─────────────────────
ProductKey = 123         CALCULATE appliqué          Filter: ProductKey = 123
Color = "Red"                                        Filter: Color = "Red"
ListPrice = 500                                      (autres colonnes ignorées)
```

### Walkthrough 2.6 : CALCULATE Force la Transition

1. **Mesure appelée dans un contexte de ligne** :

```dax
// Mesure
Ventes Totales = SUM(FactInternetSales[SalesAmount])

// Mesure utilisant SUMX
Ventes Top 10 Produits = 
SUMX(
    TOPN(10, ALL(DimProduct), [Ventes Totales], DESC),
    [Ventes Totales]  -- ← Transition de contexte automatique ici
)
```

2. **Ce qui se passe** :
   
   - **SUMX** crée un contexte de ligne sur DimProduct
   - **[Ventes Totales]** est une mesure
   - Les mesures déclenchent **automatiquement** CALCULATE
   - CALCULATE transforme le contexte de ligne en filtre

3. **Équivalent explicite** :

```dax
Ventes Top 10 Produits (Explicite) = 
SUMX(
    TOPN(10, ALL(DimProduct), [Ventes Totales], DESC),
    CALCULATE([Ventes Totales])  -- CALCULATE explicite (redondant)
)
```

### Walkthrough 2.7 : Éviter les Transitions Inutiles

1. **Problème de performance** :

```dax
// ❌ LENT - Transition de contexte à chaque ligne
Total avec Remise (Lent) = 
SUMX(
    FactInternetSales,
    [Ventes Totales] * 0.9  -- Mesure → Transition → LENT
)
```

2. **Solution optimisée** :

```dax
// ✅ RAPIDE - Pas de transition, colonnes directes
Total avec Remise (Rapide) = 
SUMX(
    FactInternetSales,
    FactInternetSales[SalesAmount] * 0.9  -- Colonne → RAPIDE
)
```

3. **Impact** : La version rapide peut être **10-100x plus performante** sur grandes tables

4. **Règle** : Dans SUMX/FILTER sur table de faits, utilisez des colonnes, pas des mesures

### Walkthrough 2.8 : EARLIER - Navigation dans les Contextes

1. **EARLIER accède au contexte de ligne externe** :

```dax
// Colonne calculée dans DimProduct
Prix Relatif = 
VAR PrixActuel = DimProduct[ListPrice]
VAR PrixMoyenCategorie = 
    CALCULATE(
        AVERAGE(DimProduct[ListPrice]),
        FILTER(
            ALL(DimProduct),
            DimProduct[ProductSubcategoryKey] = EARLIER(DimProduct[ProductSubcategoryKey])
            -- ↑ EARLIER remonte au contexte de ligne externe
        )
    )
RETURN
    DIVIDE(PrixActuel, PrixMoyenCategorie)
```

2. **Explication** :
   
   - **Contexte externe** : Ligne actuelle de DimProduct (ProductKey = 123)
   - **FILTER** crée un **nouveau** contexte de ligne sur ALL(DimProduct)
   - **EARLIER** remonte au contexte externe pour récupérer le ProductSubcategoryKey
   - Compare chaque produit au produit actuel

3. **Alternative moderne avec variables** (recommandée) :

```dax
Prix Relatif (VAR) = 
VAR SubcategoryKey = DimProduct[ProductSubcategoryKey]
VAR PrixActuel = DimProduct[ListPrice]
VAR PrixMoyenCategorie = 
    CALCULATE(
        AVERAGE(DimProduct[ListPrice]),
        FILTER(
            ALL(DimProduct),
            DimProduct[ProductSubcategoryKey] = SubcategoryKey
        )
    )
RETURN
    DIVIDE(PrixActuel, PrixMoyenCategorie)
```

4. **⚠️ EARLIER est obsolète** : Préférez toujours les variables (plus lisible)

---

## Partie 3 : Patterns de Calculs Complexes

### 3.1 Pattern : Ranking Dynamique

### Walkthrough 3.1 : Classement avec Gestion des Ex-Aequo

1. **Classement simple** :

```dax
Rang Ventes = 
RANKX(
    ALL(DimProduct[EnglishProductName]),
    [Ventes Totales],
    ,
    DESC,
    DENSE  -- Dense: pas de sauts (1,2,3...) vs Skip (1,2,2,4...)
)
```

2. **Classement avec filtre** :

```dax
Rang Ventes Catégorie = 
RANKX(
    ALLEXCEPT(DimProduct, DimProductCategory[EnglishProductCategoryName]),
    [Ventes Totales],
    ,
    DESC,
    DENSE
)
```

3. **Top N dynamique** :

```dax
Ventes Top N = 
VAR TopN = 10  -- Paramètre
RETURN
    IF(
        [Rang Ventes] <= TopN,
        [Ventes Totales],
        BLANK()
    )
```

4. **Classement avec ties (ex-aequo)** :

```dax
Rang avec Numéro Unique = 
VAR CurrentSales = [Ventes Totales]
VAR CurrentProduct = MAX(DimProduct[EnglishProductName])
VAR BetterProducts = 
    COUNTROWS(
        FILTER(
            ALL(DimProduct[EnglishProductName]),
            [Ventes Totales] > CurrentSales ||
            ([Ventes Totales] = CurrentSales && 
             DimProduct[EnglishProductName] < CurrentProduct)
        )
    )
RETURN
    BetterProducts + 1
```

### 3.2 Pattern : ABC Analysis (Pareto)

### Walkthrough 3.2 : Classification ABC

1. **Contribution cumulée** :

```dax
Contribution Cumulée = 
VAR CurrentProduct = MAX(DimProduct[EnglishProductName])
VAR CurrentRank = [Rang Ventes]
VAR TotalSales = 
    CALCULATE(
        [Ventes Totales],
        ALL(DimProduct)
    )
VAR CumulativeSales = 
    CALCULATE(
        [Ventes Totales],
        FILTER(
            ALL(DimProduct),
            [Rang Ventes] <= CurrentRank
        )
    )
RETURN
    DIVIDE(CumulativeSales, TotalSales)
```

2. **Classification ABC** :

```dax
Classe ABC = 
VAR Cumulative = [Contribution Cumulée]
RETURN
    SWITCH(
        TRUE(),
        Cumulative <= 0.80, "A (Top 80%)",
        Cumulative <= 0.95, "B (80-95%)",
        "C (Queue 5%)"
    )
```

3. **Ventes par classe** :

```dax
Ventes Classe A = 
CALCULATE(
    [Ventes Totales],
    FILTER(
        ALL(DimProduct),
        [Classe ABC] = "A (Top 80%)"
    )
)
```

### 3.3 Pattern : Moyennes Mobiles et Lissage

### Walkthrough 3.3 : Moyenne Mobile Avancée

1. **Moyenne mobile simple (3 mois)** :

```dax
MM3 = 
AVERAGEX(
    DATESINPERIOD(
        DimDate[FullDateAlternateKey],
        MAX(DimDate[FullDateAlternateKey]),
        -3,
        MONTH
    ),
    [Ventes Totales]
)
```

2. **Moyenne mobile pondérée** :

```dax
MMP3 = 
VAR CurrentMonth = [Ventes Totales]
VAR Month1 = CALCULATE([Ventes Totales], DATEADD(DimDate[FullDateAlternateKey], -1, MONTH))
VAR Month2 = CALCULATE([Ventes Totales], DATEADD(DimDate[FullDateAlternateKey], -2, MONTH))
RETURN
    DIVIDE(
        CurrentMonth * 3 + Month1 * 2 + Month2 * 1,
        6  -- Somme des poids
    )
```

3. **Moyenne mobile avec gestion des périodes incomplètes** :

```dax
MM Adaptive = 
VAR CurrentDate = MAX(DimDate[FullDateAlternateKey])
VAR DateRange = 
    DATESINPERIOD(
        DimDate[FullDateAlternateKey],
        CurrentDate,
        -3,
        MONTH
    )
VAR MonthCount = 
    COUNTROWS(
        DISTINCT(
            SELECTCOLUMNS(
                DateRange,
                "YearMonth", FORMAT([FullDateAlternateKey], "YYYYMM")
            )
        )
    )
VAR TotalSales = CALCULATE([Ventes Totales], DateRange)
RETURN
    DIVIDE(TotalSales, MonthCount)
```

### 3.4 Pattern : Same Store Sales (Ventes Magasins Comparables)

### Walkthrough 3.4 : Analyse des Ventes Comparables

1. **Identifier les entités comparables** :

```dax
// Produits présents cette année ET l'année dernière
Produits Comparables = 
VAR ProduitsAnneeActuelle = 
    CALCULATETABLE(
        VALUES(DimProduct[ProductKey]),
        DimDate[CalendarYear] = MAX(DimDate[CalendarYear])
    )
VAR ProduitsAnneePrecedente = 
    CALCULATETABLE(
        VALUES(DimProduct[ProductKey]),
        DimDate[CalendarYear] = MAX(DimDate[CalendarYear]) - 1
    )
RETURN
    INTERSECT(ProduitsAnneeActuelle, ProduitsAnneePrecedente)
```

2. **Ventes sur base comparable** :

```dax
Ventes Comparables = 
VAR ComparableProducts = [Produits Comparables]
RETURN
    CALCULATE(
        [Ventes Totales],
        ComparableProducts
    )
```

3. **Croissance comparable** :

```dax
Croissance Comparable = 
VAR VentesActuelles = [Ventes Comparables]
VAR VentesN1 = 
    CALCULATE(
        [Ventes Comparables],
        SAMEPERIODLASTYEAR(DimDate[FullDateAlternateKey])
    )
RETURN
    DIVIDE(VentesActuelles - VentesN1, VentesN1)
```

### 3.5 Pattern : Snapshot Analysis (Analyse Instantanée)

### Walkthrough 3.5 : Analyse à Date Figée

1. **Créer une table de paramètres de date** :

```dax
// Table calculée
Paramètre Date = 
{
    ("Aujourd'hui", TODAY()),
    ("Fin Mois Dernier", EOMONTH(TODAY(), -1)),
    ("Fin Année Dernière", DATE(YEAR(TODAY()) - 1, 12, 31)),
    ("Date Personnalisée", DATE(2013, 6, 30))
}
```

2. **Mesure utilisant la date sélectionnée** :

```dax
Ventes à Date Sélectionnée = 
VAR SelectedDate = 
    SELECTEDVALUE(
        'Paramètre Date'[Column2],
        TODAY()
    )
VAR SalesAtDate = 
    CALCULATE(
        [Ventes Totales],
        FILTER(
            ALL(DimDate),
            DimDate[FullDateAlternateKey] <= SelectedDate
        )
    )
RETURN
    SalesAtDate
```

3. **Comparaison Snapshot vs Actuel** :

```dax
Évolution depuis Snapshot = 
[Ventes Totales] - [Ventes à Date Sélectionnée]
```

---

## Partie 4 : Optimisation des Performances

### 4.1 Principes d'Optimisation

**Règles d'or** :

1. **Mesures > Colonnes calculées** (quand possible)
2. **Colonnes > Mesures dans SUMX/FILTER** (sur tables de faits)
3. **Variables pour réutilisation** (éviter recalculs)
4. **ALL limité** (ALL(Table) vs ALL(Colonne))
5. **Cardinalité minimum** (filtrer tôt, agréger tard)

### Walkthrough 4.1 : Comparer Mesures vs Colonnes Calculées

1. **Colonne calculée (pré-calculée au refresh)** :

```dax
// Dans FactInternetSales
Marge (Colonne) = 
FactInternetSales[SalesAmount] - FactInternetSales[TotalProductCost]

// Mesure simple
Marge Totale (Colonne) = SUM(FactInternetSales[Marge (Colonne)])
```

2. **Mesure (calculée à la demande)** :

```dax
Marge Totale (Mesure) = 
SUMX(
    FactInternetSales,
    FactInternetSales[SalesAmount] - FactInternetSales[TotalProductCost]
)
```

3. **Comparaison** :

| Critère                 | Colonne Calculée | Mesure       |
| ----------------------- | ---------------- | ------------ |
| **Calcul**              | Au refresh       | À la requête |
| **Stockage**            | Consomme RAM     | Pas de RAM   |
| **Performance requête** | ⚡⚡⚡ Très rapide  | ⚡⚡ Rapide    |
| **Taille modèle**       | ⬆️ Augmente      | → Neutre     |
| **Flexibilité**         | ❌ Fixe           | ✅ Dynamique  |

4. **Recommandation** :
   - **Colonne** : Calculs simples, réutilisés partout, rarement modifiés
   - **Mesure** : Calculs contextuels, agrégations, analyses dynamiques

### Walkthrough 4.2 : Optimiser FILTER et ALL

1. **❌ Anti-pattern : ALL sur table entière** :

```dax
// LENT - Scanne toute la table DimProduct
Ventes Produits Rouges (Lent) = 
CALCULATE(
    [Ventes Totales],
    FILTER(
        ALL(DimProduct),  -- ❌ Toute la table
        DimProduct[Color] = "Red"
    )
)
```

2. **✅ Optimisé : ALL sur colonne** :

```dax
// RAPIDE - Scanne uniquement les valeurs de Color
Ventes Produits Rouges (Rapide) = 
CALCULATE(
    [Ventes Totales],
    FILTER(
        ALL(DimProduct[Color]),  -- ✅ Juste la colonne
        DimProduct[Color] = "Red"
    )
)
```

3. **✅ Encore mieux : Filtre direct** :

```dax
// TRÈS RAPIDE - Pas de FILTER du tout
Ventes Produits Rouges (Optimal) = 
CALCULATE(
    [Ventes Totales],
    DimProduct[Color] = "Red"  -- ✅ Filtre direct
)
```

4. **Règle** : Utilisez FILTER uniquement pour des conditions complexes

### Walkthrough 4.3 : Optimiser les Variables

1. **✅ Variable pour calcul réutilisé** :

```dax
Ratio Performance = 
VAR TotalSales = [Ventes Totales]  -- ✅ Calculé 1 fois
VAR AvgSales = [Ventes Moyennes]   -- ✅ Calculé 1 fois
RETURN
    DIVIDE(
        TotalSales - AvgSales,
        AvgSales
    )
```

2. **❌ Variable pour calcul unique** :

```dax
// Inutile - la variable n'est utilisée qu'une fois
Simple Total = 
VAR Total = SUM(FactInternetSales[SalesAmount])  -- ❌ Variable superflue
RETURN
    Total
```

3. **✅ Variables pour tables filtrées** :

```dax
Analyse Segmentée = 
VAR HighValueCustomers = 
    FILTER(
        ALL(DimCustomer),
        [Ventes Totales] > 10000
    )  -- ✅ Table filtrée stockée
VAR HighValueSales = 
    CALCULATE([Ventes Totales], HighValueCustomers)
VAR HighValueCount = 
    COUNTROWS(HighValueCustomers)  -- ✅ Réutilise la table
RETURN
    DIVIDE(HighValueSales, HighValueCount)
```

### Walkthrough 4.4 : Éviter les Boucles Inutiles

1. **❌ SUMX sur table de faits avec mesure** :

```dax
// TRÈS LENT - Transition de contexte à chaque ligne
Total Marge (Lent) = 
SUMX(
    FactInternetSales,
    [Marge Totale]  -- ❌ Mesure → Transition → LENT
)
```

2. **✅ SUMX avec colonnes** :

```dax
// RAPIDE - Pas de transition
Total Marge (Rapide) = 
SUMX(
    FactInternetSales,
    FactInternetSales[SalesAmount] - FactInternetSales[TotalProductCost]
)
```

3. **✅ Encore mieux : Agrégation directe** :

```dax
// OPTIMAL - Pas de boucle du tout
Total Marge (Optimal) = 
SUM(FactInternetSales[SalesAmount]) - SUM(FactInternetSales[TotalProductCost])
```

### Walkthrough 4.5 : Matérialiser les Calculs Fréquents

1. **Table calculée pour réutilisation** :

```dax
// Table calculée (pré-agrégée au refresh)
Ventes Par Produit Jour = 
SUMMARIZECOLUMNS(
    DimProduct[ProductKey],
    DimDate[DateKey],
    "TotalSales", [Ventes Totales],
    "TotalQuantity", SUM(FactInternetSales[OrderQuantity])
)
```

2. **Avantages** :
   
   - ✅ Calculs lourds faits une seule fois (au refresh)
   - ✅ Requêtes utilisateur ultra-rapides
   - ❌ Consomme de la RAM
   - ❌ Doit être rafraîchie

3. **Quand utiliser** :
   
   - Agrégations complexes utilisées dans plusieurs rapports
   - Calculs sur grandes tables de faits
   - Données historiques (ne changent pas souvent)

### Walkthrough 4.6 : Analyser les Performances avec DAX Studio

1. **Installer DAX Studio** (outil gratuit)

2. **Analyser une mesure** :
   
   - Connectez-vous au modèle Power BI
   - Écrivez une requête :

```dax
EVALUATE
SUMMARIZECOLUMNS(
    DimProduct[EnglishProductName],
    "Ventes", [Ventes Totales],
    "Marge", [Marge Totale]
)
```

3. **Lancer avec Server Timings** (Ctrl+T)

4. **Interpréter les résultats** :
   
   - **Query duration** : Temps total
   - **Formula engine** : Temps CPU (logique DAX)
   - **Storage engine** : Temps VertiPaq (scan des colonnes)

5. **Optimiser** :
   
   - Formula engine élevé → Simplifier la logique DAX
   - Storage engine élevé → Réduire les scans de tables

### Bonnes Pratiques - Optimisation

✅ **À FAIRE** :

- Tester les mesures avec DAX Studio
- Utiliser des variables pour les calculs réutilisés
- Préférer les filtres directs à FILTER quand possible
- Limiter ALL à des colonnes spécifiques
- Matérialiser les calculs fréquents en tables calculées

❌ **À ÉVITER** :

- SUMX/FILTER sur tables de faits avec mesures
- ALL(Table) quand ALL(Colonne) suffit
- Variables pour des calculs utilisés une seule fois
- Colonnes calculées sur tables de faits pour des calculs contextuels
- Transitions de contexte inutiles dans les boucles

---

## Conclusion

Cet atelier vous a permis de maîtriser :

✅ **Variables (VAR/RETURN)** : Lisibilité, performance, débogage  
✅ **Contexte de filtre** : Propagation, modification avec CALCULATE  
✅ **Contexte de ligne** : Création avec X, colonnes calculées  
✅ **Transition de contexte** : Automatique avec mesures, CALCULATE  
✅ **Patterns avancés** : Ranking, ABC, moyennes mobiles, same store sales  
✅ **Optimisation** : Variables, ALL limité, éviter les boucles inutiles

### Points Clés à Retenir

1. **Les variables capturent le contexte au moment de leur déclaration**
2. **Contexte de ligne ≠ Contexte de filtre** (ne se propagent pas pareil)
3. **Les mesures déclenchent automatiquement CALCULATE** (transition de contexte)
4. **EARLIER est obsolète** → Utilisez des variables
5. **Performance : Colonnes > Mesures dans SUMX** sur tables de faits
6. **ALL(Colonne) >> ALL(Table)** pour les performances

### 
