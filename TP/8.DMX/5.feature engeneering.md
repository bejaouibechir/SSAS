# üéØ FEATURE ENGINEERING - LE C≈íUR DU DATA MINING

## Comment D√©nicher les Bonnes Features

---

## ‚ö†Ô∏è R√àGLE D'OR

> **"Garbage In, Garbage Out"**  
> La qualit√© des donn√©es en entr√©e d√©termine la qualit√© des r√©sultats en sortie.

> 90% du succ√®s = Bonnes features  
> 10% du succ√®s = Bon algorithme

**Mauvaises features ‚Üí Mod√®le inutile (m√™me avec meilleur algo)**  
**Bonnes features ‚Üí Mod√®le performant (m√™me avec algo simple)**

---

## üìä M√âTHODOLOGIE : 5 √âTAPES

### **√âTAPE 1 : Comprendre le Probl√®me Business**

**Question √† poser :** Qu'est-ce qui CAUSE le churn dans la r√©alit√© ?

**Explication :** Avant m√™me de regarder les donn√©es, il faut comprendre le m√©tier. Un mod√®le de pr√©diction du churn doit refl√©ter les raisons r√©elles pour lesquelles les clients quittent l'entreprise. Ici, on identifie 5 facteurs m√©tier cl√©s qui seront traduits en features.

```
‚ùå Mauvaise approche:
"Je prends toutes les colonnes disponibles"

‚úÖ Bonne approche:
"Un client churn PARCE QUE:
 - Il n'ach√®te plus depuis longtemps (RECENCY)
 - Il achetait peu souvent (FREQUENCY)
 - Il d√©pensait peu (MONETARY)
 - Il n'a pas d'historique (TENURE)
 - Ses achats diminuent (TREND)"
```



---

### **√âTAPE 2 : Identifier les Features Candidates**

**3 Cat√©gories de features :**

#### **A) Features Directes** (Colonnes existantes)

**Explication :** Ces features sont directement disponibles dans la table des clients. Elles sont statiques et d√©crivent les caract√©ristiques d√©mographiques de base. Chacune a une justification m√©tier : l'√¢ge influence les habitudes d'achat, le genre peut √™tre li√© √† des pr√©f√©rences produits, le revenu au budget, et la r√©gion aux diff√©rences culturelles ou saisonni√®res.

```sql
-- D√©j√† dans la table
SELECT 
    CustomerKey,
    Age,                    -- ‚úì Pertinent (jeunes vs √¢g√©s)
    Gender,                 -- ‚úì Pertinent (comportements diff√©rents)
    Income,                 -- ‚úì Pertinent (pouvoir d'achat)
    Region                  -- ‚úì Pertinent (g√©ographie)
FROM DimCustomer;
```



---

#### **B) Features Agr√©g√©es** (Calcul√©es depuis FactSales)

**Explication :** On agr√®ge les donn√©es de vente (FactSales) au niveau client. Cela transforme des transactions ponctuelles en indicateurs comportementaux r√©sum√©s. `TotalOrders` mesure la fr√©quence d'achat, `TotalSpent` la valeur mon√©taire, et les dates extr√™mes permettent de calculer l'anciennet√© et la r√©cence.

```sql
-- EXEMPLE : Calculer TotalOrders par client
SELECT 
    CustomerKey,
    COUNT(*) AS TotalOrders,              -- ‚úì FREQUENCY
    SUM(NetAmount) AS TotalSpent,         -- ‚úì MONETARY
    AVG(NetAmount) AS AvgOrderValue,      -- ‚úì Ticket moyen
    MAX(NetAmount) AS MaxOrderValue,      -- ‚úì Capacit√© d√©pense
    MIN(OrderDate) AS FirstPurchaseDate,  -- ‚úì Pour TENURE
    MAX(OrderDate) AS LastPurchaseDate    -- ‚úì Pour RECENCY
FROM FactSales
GROUP BY CustomerKey;
```



---

**Requ√™te SQL pour RFMT :**

**Explication :** Cette requ√™te impl√©mente le cadre RFMT (R√©cence, Fr√©quence, Mon√©taire, T√©neur), une m√©thodologie classique en marketing. Elle calcule les 4 piliers du comportement client √† partir des donn√©es de transaction. La derni√®re ligne calcule le d√©lai moyen entre deux commandes, un indicateur de r√©gularit√©. `NULLIF` √©vite une division par z√©ro pour les clients avec une seule commande.

```sql
-- Calcul complet RFMT
DECLARE @Today DATE = '2024-12-31';

SELECT 
    CustomerKey,

    -- R = RECENCY (jours depuis dernier achat)
    DATEDIFF(DAY, MAX(OrderDate), @Today) AS DaysSinceLastPurchase,

    -- F = FREQUENCY (nombre d'achats)
    COUNT(*) AS TotalOrders,

    -- M = MONETARY (montant total)
    SUM(NetAmount) AS TotalSpent,
    AVG(NetAmount) AS AvgOrderValue,

    -- T = TENURE (anciennet√©)
    DATEDIFF(DAY, MIN(OrderDate), @Today) AS DaysSinceFirstPurchase,

    -- Features d√©riv√©es
    DATEDIFF(DAY, MIN(OrderDate), MAX(OrderDate)) / NULLIF(COUNT(*) - 1, 0) AS AvgDaysBetweenOrders

FROM FactSales
GROUP BY CustomerKey;
```



---

#### **C) Features D√©riv√©es** (Combinaisons)

**Explication :** On cr√©e des features "intelligentes" en combinant et comparant des m√©triques. `PercentRecent90Days` mesure la proportion d'achats r√©cents : un client qui a 100% de ses achats dans les 90 derniers jours est tr√®s actif, tandis que 0% sugg√®re une d√©sactivation. `RecentSpendRatio` fait de m√™me pour le budget. Les comptes distincts (`COUNT(DISTINCT ...)`) mesurent la diversit√© du panier, indicateur d'engagement ou de fid√©lit√©.

```sql
-- EXEMPLE : Taux d'activit√© r√©cente
SELECT 
    CustomerKey,

    -- % achats dans les 90 derniers jours
    SUM(CASE WHEN DATEDIFF(DAY, OrderDate, @Today) <= 90 THEN 1 ELSE 0 END) * 100.0 
        / NULLIF(COUNT(*), 0) AS PercentRecent90Days,

    -- Tendance (ratio recent vs ancien)
    SUM(CASE WHEN DATEDIFF(DAY, OrderDate, @Today) <= 90 THEN NetAmount ELSE 0 END) 
        / NULLIF(SUM(NetAmount), 0) AS RecentSpendRatio,

    -- Diversit√© produits
    COUNT(DISTINCT ProductKey) AS UniqueProducts,
    COUNT(DISTINCT p.Category) AS UniqueCategories

FROM FactSales s
JOIN DimProduct p ON s.ProductKey = p.ProductKey
GROUP BY CustomerKey;
```



---

### **√âTAPE 3 : Tester la Pertinence**

**M√©thode 1 : Analyse de Corr√©lation**

**Explication :** On compare la valeur moyenne de chaque feature pour les clients actifs et ceux ayant quitt√© (churn). Si les moyennes sont tr√®s diff√©rentes (ex: 45 vs 350 jours de r√©cence), la feature a un fort pouvoir discriminatif. C'est un test simple pour valider l'intuition m√©tier avec des donn√©es.

```sql
-- Comparer features entre ACTIFS et CHURN√âS
SELECT 
    'CHURNED' AS Status,
    AVG(DaysSinceLastPurchase) AS AvgRecency,
    AVG(TotalOrders) AS AvgFrequency,
    AVG(TotalSpent) AS AvgMonetary
FROM DimCustomer
WHERE HasChurned = 1

UNION ALL

SELECT 
    'ACTIVE',
    AVG(DaysSinceLastPurchase),
    AVG(TotalOrders),
    AVG(TotalSpent)
FROM DimCustomer
WHERE HasChurned = 0;

/* R√âSULTAT ATTENDU:
Status    AvgRecency  AvgFrequency  AvgMonetary
CHURNED   350 jours   3.2 orders    ‚Ç¨245
ACTIVE    45 jours    12.8 orders   ‚Ç¨1,240

‚Üí Diff√©rence CLAIRE = Feature PERTINENTE! ‚úì
*/
```



---

**M√©thode 2 : Distribution par Segment**

**Explication :** On segmente les clients en "buckets" (groupes) bas√©s sur la feature (ici, la r√©cence). On calcule ensuite le taux de churn pour chaque groupe. Une progression claire et monotone du taux de churn entre les groupes (3% ‚Üí 94%) prouve une relation forte et pr√©dictive. C'est plus informatif qu'une simple moyenne.

```sql
-- Feature pertinente si distributions diff√©rentes
SELECT 
    CASE 
        WHEN DaysSinceLastPurchase <= 30 THEN '0-30 days'
        WHEN DaysSinceLastPurchase <= 90 THEN '31-90 days'
        WHEN DaysSinceLastPurchase <= 180 THEN '91-180 days'
        ELSE '180+ days'
    END AS RecencyBucket,
    COUNT(*) AS TotalClients,
    SUM(CASE WHEN HasChurned = 1 THEN 1 ELSE 0 END) AS ChurnedClients,
    SUM(CASE WHEN HasChurned = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) AS ChurnRate
FROM DimCustomer
GROUP BY 
    CASE 
        WHEN DaysSinceLastPurchase <= 30 THEN '0-30 days'
        WHEN DaysSinceLastPurchase <= 90 THEN '31-90 days'
        WHEN DaysSinceLastPurchase <= 180 THEN '91-180 days'
        ELSE '180+ days'
    END
ORDER BY ChurnRate;

/* R√âSULTAT ATTENDU:
RecencyBucket  TotalClients  ChurnedClients  ChurnRate
0-30 days      150           5               3%        ‚Üê Excellent pr√©dicteur!
31-90 days     120           12              10%
91-180 days    80            32              40%
180+ days      150           141             94%       ‚Üê Presque tous churn√©s!

‚Üí Corr√©lation FORTE = Feature EXCELLENTE! ‚úì‚úì‚úì
*/
```



---

**‚ùå Feature √† REJETER :**

**Explication :** Cette requ√™te teste si la premi√®re lettre du code client (un identifiant souvent arbitraire) est li√©e au churn. Les r√©sultats montrent des taux de churn similaires (~49-51%) pour toutes les lettres, ce qui signifie qu'il n'y a **aucune relation**. C'est un exemple de feature √† exclure car elle n'apporte aucune information pour la pr√©diction. Le test permet d'√©viter le "bruit" dans le mod√®le.

```sql
-- Test: CustomerCode a-t-il un impact ?
SELECT 
    LEFT(CustomerCode, 1) AS FirstLetter,
    AVG(CAST(HasChurned AS FLOAT)) AS ChurnRate
FROM DimCustomer
GROUP BY LEFT(CustomerCode, 1);

/* R√âSULTAT:
FirstLetter  ChurnRate
C            0.48
C            0.49
C            0.51

‚Üí Pas de diff√©rence = Feature INUTILE ‚úó
*/
```



---

### **√âTAPE 4 : Transformer les Features**

**A) Normalisation (Scores 1-5)**

**Explication :** On convertit une valeur continue (jours) en cat√©gorie ordinale (score de 1 √† 5). Cela simplifie l'interpr√©tation et peut am√©liorer la performance de certains algorithmes, surtout ceux bas√©s sur des arbres. De plus, cela rend la feature plus robuste aux valeurs extr√™mes (outliers). Le seuillage est d√©fini par des connaissances m√©tier (ex: ‚â§30 jours = client tr√®s actif).

```sql
-- Transformer valeur continue en score discret
SELECT 
    CustomerKey,
    DaysSinceLastPurchase,
    CASE 
        WHEN DaysSinceLastPurchase <= 30 THEN 5   -- Excellent
        WHEN DaysSinceLastPurchase <= 90 THEN 4   -- Bon
        WHEN DaysSinceLastPurchase <= 180 THEN 3  -- Moyen
        WHEN DaysSinceLastPurchase <= 365 THEN 2  -- Faible
        ELSE 1                                     -- Tr√®s faible
    END AS RecencyScore
FROM DimCustomer;

-- POURQUOI ? Algorithmes pr√©f√®rent valeurs normalis√©es
```



---

**B) Cat√©gorisation**

**Explication :** L'√¢ge en tant que nombre continu peut avoir une relation non-lin√©aire avec le churn (les tr√®s jeunes et les seniors churnent plus, les quadras moins). En le regroupant en cat√©gories, on permet √† l'algorithme de capturer ces effets sans avoir √† les mod√©liser explicitement. C'est souvent plus efficace qu'utiliser l'√¢ge brut.

```sql
-- Transformer num√©rique en cat√©gorie
SELECT 
    CustomerKey,
    Age,
    CASE 
        WHEN Age BETWEEN 18 AND 25 THEN '18-25'
        WHEN Age BETWEEN 26 AND 35 THEN '26-35'
        WHEN Age BETWEEN 36 AND 45 THEN '36-45'
        WHEN Age BETWEEN 46 AND 60 THEN '46-60'
        ELSE '60+'
    END AS AgeGroup
FROM DimCustomer;

-- POURQUOI ? Capture patterns non-lin√©aires
-- Exemple: Churn √©lev√© 18-25 ET 60+, bas 36-45
```



---

**C) Ratios et Pourcentages**

**Explication :** Les valeurs absolues (ex: 10 achats) sont difficiles √† interpr√©ter sans contexte : est-ce beaucoup pour un client r√©cent ? Un ratio comme `PercentRecent90Days` donne un contexte : 100% signifie que le client n'a achet√© que r√©cemment, ce qui est un signal positif. `SpendPerDay` normalise la d√©pense totale par l'anciennet√©, permettant de comparer √©quitablement un client de 2 ans avec un client de 10 ans.

```sql
-- Plus puissant que valeurs absolues
SELECT 
    CustomerKey,

    -- Absolute (moins pertinent)
    OrdersLast90Days,
    TotalOrders,

    -- Ratio (plus pertinent!)
    OrdersLast90Days * 100.0 / NULLIF(TotalOrders, 0) AS PercentRecent90Days,

    -- Autre exemple
    TotalSpent / NULLIF(DaysSinceFirstPurchase, 0) AS SpendPerDay

FROM DimCustomer;

-- POURQUOI ? Compare clients ind√©pendamment de l'anciennet√©
```



---

### **√âTAPE 5 : Extraire Features pour Mining Structure**



**Vue SQL finale pour Mining :**

**Explication :** Cette vue rassemble toutes les features s√©lectionn√©es et transform√©es, pr√™tes √† √™tre consomm√©es par l'outil de Data Mining (ex: SSAS). Elle inclut des scores RFMT, des donn√©es d√©mographiques cat√©goris√©es, des indicateurs comportementaux complexes et m√™me un motif saisonnier. La clause `WHERE` filtre les clients de moins de 90 jours car ils n'ont pas assez d'historique pour calculer des tendances fiables, ce qui pourrait fausser le mod√®le.

```sql
CREATE VIEW vw_ChurnPrediction_Features AS
SELECT 
    c.CustomerKey,

    -- RFMT Scores (1-5) ‚Üê MEILLEURS pour classification
    c.RecencyScore,
    c.FrequencyScore,
    c.MonetaryScore,
    c.TenureScore,

    -- D√©mographiques
    c.AgeGroup,
    c.Gender,
    c.IncomeGroup,
    c.Region,

    -- Comportementales
    c.PurchaseTrend,                      -- Increasing/Stable/Decreasing
    c.AvgDaysBetweenOrders,
    c.UniqueBrandsPurchased,
    c.UniqueCategoriesPurchased,
    c.PercentDiscountPurchases,
    c.ReturnRate,

    -- Pr√©f√©rences
    c.FavoriteCategory,
    c.PreferredPriceRange,

    -- Saisonnalit√©
    CASE 
        WHEN c.PurchasesInWinter > (c.TotalOrders / 4.0) THEN 'Winter'
        WHEN c.PurchasesInSummer > (c.TotalOrders / 4.0) THEN 'Summer'
        WHEN c.PurchasesInSpring > (c.TotalOrders / 4.0) THEN 'Spring'
        WHEN c.PurchasesInFall > (c.TotalOrders / 4.0) THEN 'Fall'
        ELSE 'No Pattern'
    END AS SeasonalPattern,

    -- LABEL (ce qu'on veut pr√©dire)
    c.HasChurned                          -- 0 = Active, 1 = Churned

FROM DimCustomer c
WHERE c.DaysSinceFirstPurchase >= 90;    -- Exclure clients trop r√©cents

-- POURQUOI exclure nouveaux clients ?
-- Pas assez d'historique pour features comportementales fiables
```



---

## üéØ FEATURES S√âLECTIONN√âES POUR CHURN

### **Top 10 Features (par ordre d'importance)**

```
1. RecencyScore (R)               ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Critique!
2. FrequencyScore (F)             ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Critique!
3. PurchaseTrend                  ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Critique!
4. MonetaryScore (M)              ‚≠ê‚≠ê‚≠ê‚≠ê
5. TenureScore (T)                ‚≠ê‚≠ê‚≠ê‚≠ê
6. AvgDaysBetweenOrders           ‚≠ê‚≠ê‚≠ê‚≠ê
7. AgeGroup                       ‚≠ê‚≠ê‚≠ê
8. IncomeGroup                    ‚≠ê‚≠ê‚≠ê
9. UniqueCategoriesPurchased      ‚≠ê‚≠ê
10. FavoriteCategory              ‚≠ê‚≠ê
```

**Justification :**

**Explication :** Cette analyse valide l'importance cruciale de la r√©cence. Le taux de churn augmente de fa√ßon spectaculaire et coh√©rente √† mesure que le score de r√©cence diminue (de 2% pour les plus r√©cents √† 95% pour les plus anciens). Une telle relation monotone et forte en fait la feature la plus pr√©dictive. C'est ce type de validation quantitative qui guide le classement.

```sql
-- Test importance: Churn Rate par RecencyScore
SELECT 
    RecencyScore,
    COUNT(*) AS Clients,
    AVG(CAST(HasChurned AS FLOAT)) * 100 AS ChurnRate
FROM DimCustomer
GROUP BY RecencyScore
ORDER BY RecencyScore DESC;

/* R√âSULTAT:
RecencyScore  Clients  ChurnRate
5 (‚â§30j)      150      2%        ‚Üê Excellent pr√©dicteur!
4 (‚â§90j)      120      8%
3 (‚â§180j)     80       35%
2 (‚â§365j)     90       72%
1 (>365j)     60       95%       ‚Üê Presque tous churn√©s!

‚Üí Relation LIN√âAIRE forte = Feature TOP ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
*/
```



---

## ‚ùå PI√àGES √Ä √âVITER

### **Pi√®ge 1 : Data Leakage**

**Explication :** Le "Data Leakage" se produit lorsqu'on inclut dans les features une information qui ne serait pas disponible au moment de la pr√©diction en r√©alit√©, ou pire, la variable cible elle-m√™me (`HasChurned`). Ici, utiliser `HasChurned` comme feature permettrait au mod√®le d'apprendre parfaitement sans comprendre les causes, mais il √©chouera compl√®tement sur de nouveaux clients dont on ne conna√Æt pas encore le statut.###  

```sql
-- ‚ùå ERREUR: Utiliser la cons√©quence comme feature
SELECT 
    CustomerKey,
    DaysSinceLastPurchase,  -- ‚úì OK
    HasChurned              -- ‚ùå C'EST LE LABEL! Pas une feature!
FROM DimCustomer;

-- Le mod√®le "tricherait" en voyant directement la r√©ponse
```

**

---

### **Pi√®ge 2 : Trop de Features**

**Explication :** L'"overfitting" (surapprentissage) se produit quand un mod√®le est trop complexe et apprend par c≈ìur le bruit et les d√©tails sp√©cifiques des donn√©es d'entra√Ænement, au lieu des patterns g√©n√©raux. Avec trop de features (surtout si certaines sont inutiles), le mod√®le perd en capacit√© √† g√©n√©raliser sur de nouvelles donn√©es, ce qui le rend inefficace en production.

```
‚ùå 100 features ‚Üí Overfitting ‚Üí Mod√®le inutile en production
‚úì 10-20 features pertinentes ‚Üí G√©n√©ralisation ‚Üí Mod√®le robuste
```



---

### **Pi√®ge 3 : Features Redondantes**

**Explication :** `TotalSpent` (d√©pense totale) et `AverageOrderValue` (valeur moyenne par commande) sont math√©matiquement li√©s si on conna√Æt `TotalOrders`. Inclure les trois introduit de la colin√©arit√© (multicollin√©arit√©), ce qui peut rendre le mod√®le instable et difficile √† interpr√©ter. Il vaut mieux choisir une seule mesure synth√©tique, comme `MonetaryScore`.

```sql
-- ‚ùå Ces 3 features disent la m√™me chose:
SELECT 
    TotalSpent,                    -- Redondant
    AverageOrderValue,             -- Redondant
    TotalOrders,                   -- Redondant
    -- Choisir 1 seule: TotalSpent OU MonetaryScore

-- ‚úì Mieux:
SELECT 
    MonetaryScore,                 -- Normalis√© 1-5
    FrequencyScore                 -- Diff√©rent
```



---

### **Pi√®ge 4 : Ignorer les Valeurs Manquantes**

**Explication :** Les valeurs NULL peuvent casser les calculs et induire en erreur les algorithmes. Ici, on les remplace par une valeur par d√©faut logique : un `ReturnRate` NULL signifie probablement que le client n'a jamais fait de retour, donc un taux de 0% est appropri√©. Cette √©tape de nettoyage est cruciale.

```sql
-- G√©rer NULL explicitement
SELECT 
    CustomerKey,
    ISNULL(ReturnRate, 0) AS ReturnRate,          -- 0 si jamais retourn√©
    ISNULL(PercentDiscountPurchases, 0) AS PercentDiscountPurchases
FROM DimCustomer;
```



---

## üîç VALIDATION FINALE

**Checklist avant Mining Structure :**

```
‚òê Chaque feature a une JUSTIFICATION business
‚òê Diff√©rence claire entre Churn√©s et Actifs
‚òê Pas de data leakage (pas de cons√©quences comme features)
‚òê Valeurs normalis√©es (scores 1-5 ou cat√©gories)
‚òê NULL g√©r√©s (ISNULL, valeurs par d√©faut)
‚òê 10-20 features maximum (pas 100!)
‚òê Vue SQL cr√©√©e et test√©e
‚òê Distribution features v√©rifi√©e
```

**Test final :**

**Explication :** Ces requ√™tes de validation sont essentielles avant de lancer l'entra√Ænement du mod√®le. On v√©rifie d'abord un √©chantillon des donn√©es, puis l'absence de NULLs critiques, et enfin l'√©quilibre des classes. Un d√©s√©quilibre extr√™me (ex: 95% de clients actifs) pourrait n√©cessiter des techniques sp√©ciales (sur/ sous-√©chantillonnage) pour que le mod√®le n'ignore pas la classe minoritaire (les churn).

```sql
-- V√©rifier distribution features
SELECT TOP 100 * FROM vw_ChurnPrediction_Features;

-- V√©rifier NULL
SELECT 
    COUNT(*) AS Total,
    COUNT(RecencyScore) AS RecencyNotNull,
    COUNT(AgeGroup) AS AgeGroupNotNull
FROM vw_ChurnPrediction_Features;

-- V√©rifier √©quilibre classes
SELECT 
    HasChurned,
    COUNT(*) AS Count,
    COUNT(*) * 100.0 / (SELECT COUNT(*) FROM vw_ChurnPrediction_Features) AS Percent
FROM vw_ChurnPrediction_Features
GROUP BY HasChurned;

/* R√âSULTAT ID√âAL:
HasChurned  Count  Percent
0           245    49%      ‚Üê √âquilibr√© ‚úì
1           255    51%
*/
```



---

## üìä EXTRACTION MDX (Pour Mining depuis Cube)

**Si features dans cube SSAS :**

**Mais PR√âF√âRER vue SQL directe !**  
Mining Structure lit mieux depuis SQL Server que depuis Cube.

**Explication :** MDX est le langage de requ√™te pour les cubes SSAS (Analysis Services). Cette requ√™te extrait les scores RFMT pour tous les clients en 2024. Cependant, comme indiqu√©, il est g√©n√©ralement plus simple et performant de cr√©er une vue SQL dans la base de donn√©es relationnelle et de laisser l'outil de Data Mining lire directement depuis cette vue, plut√¥t que de passer par la complexit√© d'un cube.

```mdx
-- Extraire features depuis cube pour Mining
SELECT 
  {
    [Measures].[RecencyScore],
    [Measures].[FrequencyScore],
    [Measures].[MonetaryScore],
    [Measures].[TenureScore]
  } ON COLUMNS,

  [Dim Customer].[Customer Key].[Customer Key].Members ON ROWS

FROM [Shoes Cube]

WHERE [Dim Time].[Year].&[2024]
```



---

## üéì R√âSUM√â ULTRA-CONCIS

```
1. COMPRENDRE le probl√®me business
   ‚Üí Pourquoi le churn se produit r√©ellement ?

2. IDENTIFIER features candidates
   ‚Üí Directes + Agr√©g√©es + D√©riv√©es

3. TESTER pertinence
   ‚Üí Comparer Churn√©s vs Actifs
   ‚Üí Distribution diff√©rente = feature pertinente

4. TRANSFORMER
   ‚Üí Scores 1-5
   ‚Üí Cat√©gories
   ‚Üí Ratios

5. VALIDER
   ‚Üí Pas de leakage
   ‚Üí Pas de redondance
   ‚Üí 10-20 features max

R√àGLE D'OR:
Feature pertinente = Distribution DIFF√âRENTE entre classes
```

---

## ‚úÖ VUE SQL FINALE PR√äTE

La vue **`vw_ChurnPrediction_Features`** est maintenant pr√™te pour cr√©er la Mining Structure !

**Prochaine √©tape :** MINING_4_Mining_Structures.md  
(Cr√©ation structures SSAS avec ces features)

---

**üéØ Features = 90% du succ√®s. Temps investi ici = temps gagn√© plus tard !**
