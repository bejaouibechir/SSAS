# üéØ FEATURE ENGINEERING - LE C≈íUR DU DATA MINING

## Comment D√©nicher les Bonnes Features

---

## ‚ö†Ô∏è R√àGLE D'OR

> **"Garbage In, Garbage Out"**
> 
> 90% du succ√®s = Bonnes features  
> 10% du succ√®s = Bon algorithme

**Mauvaises features ‚Üí Mod√®le inutile (m√™me avec meilleur algo)**  
**Bonnes features ‚Üí Mod√®le performant (m√™me avec algo simple)**

---

## üìä M√âTHODOLOGIE : 5 √âTAPES

### **√âTAPE 1 : Comprendre le Probl√®me Business**

**Question √† poser :** Qu'est-ce qui CAUSE le churn dans la r√©alit√© ?

```
‚ùå Mauvaise approche:
"Je prends toutes les colonnes disponibles"

‚úÖ Bonne approche:
"Un client churn PARCE QUE:
 - Il n'ach√®te plus depuis longtemps (RECENCY)
 - Il achetait peu souvent (FREQUENCY)
 - Il d√©pensait peu (MONETARY)
 - Il n'a pas d'historique (TENURE)
 - Ses achats diminuent (TREND)"
```

### **√âTAPE 2 : Identifier les Features Candidates**

**3 Cat√©gories de features :**

#### **A) Features Directes** (Colonnes existantes)

```sql
-- D√©j√† dans la table
SELECT 
    CustomerKey,
    Age,                    -- ‚úì Pertinent (jeunes vs √¢g√©s)
    Gender,                 -- ‚úì Pertinent (comportements diff√©rents)
    Income,                 -- ‚úì Pertinent (pouvoir d'achat)
    Region                  -- ‚úì Pertinent (g√©ographie)
FROM DimCustomer;
```

#### **B) Features Agr√©g√©es** (Calcul√©es depuis FactSales)

```sql
-- EXEMPLE : Calculer TotalOrders par client
SELECT 
    CustomerKey,
    COUNT(*) AS TotalOrders,              -- ‚úì FREQUENCY
    SUM(NetAmount) AS TotalSpent,         -- ‚úì MONETARY
    AVG(NetAmount) AS AvgOrderValue,      -- ‚úì Ticket moyen
    MAX(NetAmount) AS MaxOrderValue,      -- ‚úì Capacit√© d√©pense
    MIN(OrderDate) AS FirstPurchaseDate,  -- ‚úì Pour TENURE
    MAX(OrderDate) AS LastPurchaseDate    -- ‚úì Pour RECENCY
FROM FactSales
GROUP BY CustomerKey;
```

**Requ√™te SQL pour RFMT :**

```sql
-- Calcul complet RFMT
DECLARE @Today DATE = '2024-12-31';

SELECT 
    CustomerKey,

    -- R = RECENCY (jours depuis dernier achat)
    DATEDIFF(DAY, MAX(OrderDate), @Today) AS DaysSinceLastPurchase,

    -- F = FREQUENCY (nombre d'achats)
    COUNT(*) AS TotalOrders,

    -- M = MONETARY (montant total)
    SUM(NetAmount) AS TotalSpent,
    AVG(NetAmount) AS AvgOrderValue,

    -- T = TENURE (anciennet√©)
    DATEDIFF(DAY, MIN(OrderDate), @Today) AS DaysSinceFirstPurchase,

    -- Features d√©riv√©es
    DATEDIFF(DAY, MIN(OrderDate), MAX(OrderDate)) / NULLIF(COUNT(*) - 1, 0) AS AvgDaysBetweenOrders

FROM FactSales
GROUP BY CustomerKey;
```

#### **C) Features D√©riv√©es** (Combinaisons)

```sql
-- EXEMPLE : Taux d'activit√© r√©cente
SELECT 
    CustomerKey,

    -- % achats dans les 90 derniers jours
    SUM(CASE WHEN DATEDIFF(DAY, OrderDate, @Today) <= 90 THEN 1 ELSE 0 END) * 100.0 
        / NULLIF(COUNT(*), 0) AS PercentRecent90Days,

    -- Tendance (ratio recent vs ancien)
    SUM(CASE WHEN DATEDIFF(DAY, OrderDate, @Today) <= 90 THEN NetAmount ELSE 0 END) 
        / NULLIF(SUM(NetAmount), 0) AS RecentSpendRatio,

    -- Diversit√© produits
    COUNT(DISTINCT ProductKey) AS UniqueProducts,
    COUNT(DISTINCT p.Category) AS UniqueCategories

FROM FactSales s
JOIN DimProduct p ON s.ProductKey = p.ProductKey
GROUP BY CustomerKey;
```

---

### **√âTAPE 3 : Tester la Pertinence**

**M√©thode 1 : Analyse de Corr√©lation**

```sql
-- Comparer features entre ACTIFS et CHURN√âS
SELECT 
    'CHURNED' AS Status,
    AVG(DaysSinceLastPurchase) AS AvgRecency,
    AVG(TotalOrders) AS AvgFrequency,
    AVG(TotalSpent) AS AvgMonetary
FROM DimCustomer
WHERE HasChurned = 1

UNION ALL

SELECT 
    'ACTIVE',
    AVG(DaysSinceLastPurchase),
    AVG(TotalOrders),
    AVG(TotalSpent)
FROM DimCustomer
WHERE HasChurned = 0;

/* R√âSULTAT ATTENDU:
Status    AvgRecency  AvgFrequency  AvgMonetary
CHURNED   350 jours   3.2 orders    ‚Ç¨245
ACTIVE    45 jours    12.8 orders   ‚Ç¨1,240

‚Üí Diff√©rence CLAIRE = Feature PERTINENTE! ‚úì
*/
```

**M√©thode 2 : Distribution par Segment**

```sql
-- Feature pertinente si distributions diff√©rentes
SELECT 
    CASE 
        WHEN DaysSinceLastPurchase <= 30 THEN '0-30 days'
        WHEN DaysSinceLastPurchase <= 90 THEN '31-90 days'
        WHEN DaysSinceLastPurchase <= 180 THEN '91-180 days'
        ELSE '180+ days'
    END AS RecencyBucket,
    COUNT(*) AS TotalClients,
    SUM(CASE WHEN HasChurned = 1 THEN 1 ELSE 0 END) AS ChurnedClients,
    SUM(CASE WHEN HasChurned = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) AS ChurnRate
FROM DimCustomer
GROUP BY 
    CASE 
        WHEN DaysSinceLastPurchase <= 30 THEN '0-30 days'
        WHEN DaysSinceLastPurchase <= 90 THEN '31-90 days'
        WHEN DaysSinceLastPurchase <= 180 THEN '91-180 days'
        ELSE '180+ days'
    END
ORDER BY ChurnRate;

/* R√âSULTAT ATTENDU:
RecencyBucket  TotalClients  ChurnedClients  ChurnRate
0-30 days      150           5               3%
31-90 days     120           12              10%
91-180 days    80            32              40%
180+ days      150           141             94%

‚Üí Corr√©lation FORTE = Feature EXCELLENTE! ‚úì‚úì‚úì
*/
```

**‚ùå Feature √† REJETER :**

```sql
-- Test: CustomerCode a-t-il un impact ?
SELECT 
    LEFT(CustomerCode, 1) AS FirstLetter,
    AVG(CAST(HasChurned AS FLOAT)) AS ChurnRate
FROM DimCustomer
GROUP BY LEFT(CustomerCode, 1);

/* R√âSULTAT:
FirstLetter  ChurnRate
C            0.48
C            0.49
C            0.51

‚Üí Pas de diff√©rence = Feature INUTILE ‚úó
*/
```

---

### **√âTAPE 4 : Transformer les Features**

**A) Normalisation (Scores 1-5)**

```sql
-- Transformer valeur continue en score discret
SELECT 
    CustomerKey,
    DaysSinceLastPurchase,
    CASE 
        WHEN DaysSinceLastPurchase <= 30 THEN 5   -- Excellent
        WHEN DaysSinceLastPurchase <= 90 THEN 4   -- Bon
        WHEN DaysSinceLastPurchase <= 180 THEN 3  -- Moyen
        WHEN DaysSinceLastPurchase <= 365 THEN 2  -- Faible
        ELSE 1                                     -- Tr√®s faible
    END AS RecencyScore
FROM DimCustomer;

-- POURQUOI ? Algorithmes pr√©f√®rent valeurs normalis√©es
```

**B) Cat√©gorisation**

```sql
-- Transformer num√©rique en cat√©gorie
SELECT 
    CustomerKey,
    Age,
    CASE 
        WHEN Age BETWEEN 18 AND 25 THEN '18-25'
        WHEN Age BETWEEN 26 AND 35 THEN '26-35'
        WHEN Age BETWEEN 36 AND 45 THEN '36-45'
        WHEN Age BETWEEN 46 AND 60 THEN '46-60'
        ELSE '60+'
    END AS AgeGroup
FROM DimCustomer;

-- POURQUOI ? Capture patterns non-lin√©aires
-- Exemple: Churn √©lev√© 18-25 ET 60+, bas 36-45
```

**C) Ratios et Pourcentages**

```sql
-- Plus puissant que valeurs absolues
SELECT 
    CustomerKey,

    -- Absolute (moins pertinent)
    OrdersLast90Days,
    TotalOrders,

    -- Ratio (plus pertinent!)
    OrdersLast90Days * 100.0 / NULLIF(TotalOrders, 0) AS PercentRecent90Days,

    -- Autre exemple
    TotalSpent / NULLIF(DaysSinceFirstPurchase, 0) AS SpendPerDay

FROM DimCustomer;

-- POURQUOI ? Compare clients ind√©pendamment de l'anciennet√©
```

---

### **√âTAPE 5 : Extraire Features pour Mining Structure**

**Vue SQL finale pour Mining :**

```sql
CREATE VIEW vw_ChurnPrediction_Features AS
SELECT 
    c.CustomerKey,

    -- RFMT Scores (1-5) ‚Üê MEILLEURS pour classification
    c.RecencyScore,
    c.FrequencyScore,
    c.MonetaryScore,
    c.TenureScore,

    -- D√©mographiques
    c.AgeGroup,
    c.Gender,
    c.IncomeGroup,
    c.Region,

    -- Comportementales
    c.PurchaseTrend,                      -- Increasing/Stable/Decreasing
    c.AvgDaysBetweenOrders,
    c.UniqueBrandsPurchased,
    c.UniqueCategoriesPurchased,
    c.PercentDiscountPurchases,
    c.ReturnRate,

    -- Pr√©f√©rences
    c.FavoriteCategory,
    c.PreferredPriceRange,

    -- Saisonnalit√©
    CASE 
        WHEN c.PurchasesInWinter > (c.TotalOrders / 4.0) THEN 'Winter'
        WHEN c.PurchasesInSummer > (c.TotalOrders / 4.0) THEN 'Summer'
        WHEN c.PurchasesInSpring > (c.TotalOrders / 4.0) THEN 'Spring'
        WHEN c.PurchasesInFall > (c.TotalOrders / 4.0) THEN 'Fall'
        ELSE 'No Pattern'
    END AS SeasonalPattern,

    -- LABEL (ce qu'on veut pr√©dire)
    c.HasChurned                          -- 0 = Active, 1 = Churned

FROM DimCustomer c
WHERE c.DaysSinceFirstPurchase >= 90;    -- Exclure clients trop r√©cents

-- POURQUOI exclure nouveaux clients ?
-- Pas assez d'historique pour features comportementales fiables
```

---

## üéØ FEATURES S√âLECTIONN√âES POUR CHURN

### **Top 10 Features (par ordre d'importance)**

```
1. RecencyScore (R)               ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Critique!
2. FrequencyScore (F)             ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Critique!
3. PurchaseTrend                  ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Critique!
4. MonetaryScore (M)              ‚≠ê‚≠ê‚≠ê‚≠ê
5. TenureScore (T)                ‚≠ê‚≠ê‚≠ê‚≠ê
6. AvgDaysBetweenOrders           ‚≠ê‚≠ê‚≠ê‚≠ê
7. AgeGroup                       ‚≠ê‚≠ê‚≠ê
8. IncomeGroup                    ‚≠ê‚≠ê‚≠ê
9. UniqueCategoriesPurchased      ‚≠ê‚≠ê
10. FavoriteCategory              ‚≠ê‚≠ê
```

**Justification :**

```sql
-- Test importance: Churn Rate par RecencyScore
SELECT 
    RecencyScore,
    COUNT(*) AS Clients,
    AVG(CAST(HasChurned AS FLOAT)) * 100 AS ChurnRate
FROM DimCustomer
GROUP BY RecencyScore
ORDER BY RecencyScore DESC;

/* R√âSULTAT:
RecencyScore  Clients  ChurnRate
5 (‚â§30j)      150      2%        ‚Üê Excellent pr√©dicteur!
4 (‚â§90j)      120      8%
3 (‚â§180j)     80       35%
2 (‚â§365j)     90       72%
1 (>365j)     60       95%       ‚Üê Presque tous churn√©s!

‚Üí Relation LIN√âAIRE forte = Feature TOP ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
*/
```

---

## ‚ùå PI√àGES √Ä √âVITER

### **Pi√®ge 1 : Data Leakage**

```sql
-- ‚ùå ERREUR: Utiliser la cons√©quence comme feature
SELECT 
    CustomerKey,
    DaysSinceLastPurchase,  -- ‚úì OK
    HasChurned              -- ‚ùå C'EST LE LABEL! Pas une feature!
FROM DimCustomer;

-- Le mod√®le "tricherait" en voyant directement la r√©ponse
```

### **Pi√®ge 2 : Trop de Features**

```
‚ùå 100 features ‚Üí Overfitting ‚Üí Mod√®le inutile en production
‚úì 10-20 features pertinentes ‚Üí G√©n√©ralisation ‚Üí Mod√®le robuste
```

### **Pi√®ge 3 : Features Redondantes**

```sql
-- ‚ùå Ces 3 features disent la m√™me chose:
SELECT 
    TotalSpent,                    -- Redondant
    AverageOrderValue,             -- Redondant
    TotalOrders,                   -- Redondant
    -- Choisir 1 seule: TotalSpent OU MonetaryScore

-- ‚úì Mieux:
SELECT 
    MonetaryScore,                 -- Normalis√© 1-5
    FrequencyScore                 -- Diff√©rent
```

### **Pi√®ge 4 : Ignorer les Valeurs Manquantes**

```sql
-- G√©rer NULL explicitement
SELECT 
    CustomerKey,
    ISNULL(ReturnRate, 0) AS ReturnRate,          -- 0 si jamais retourn√©
    ISNULL(PercentDiscountPurchases, 0) AS PercentDiscountPurchases
FROM DimCustomer;
```

---

## üîç VALIDATION FINALE

**Checklist avant Mining Structure :**

```
‚òê Chaque feature a une JUSTIFICATION business
‚òê Diff√©rence claire entre Churn√©s et Actifs
‚òê Pas de data leakage (pas de cons√©quences comme features)
‚òê Valeurs normalis√©es (scores 1-5 ou cat√©gories)
‚òê NULL g√©r√©s (ISNULL, valeurs par d√©faut)
‚òê 10-20 features maximum (pas 100!)
‚òê Vue SQL cr√©√©e et test√©e
‚òê Distribution features v√©rifi√©e
```

**Test final :**

```sql
-- V√©rifier distribution features
SELECT TOP 100 * FROM vw_ChurnPrediction_Features;

-- V√©rifier NULL
SELECT 
    COUNT(*) AS Total,
    COUNT(RecencyScore) AS RecencyNotNull,
    COUNT(AgeGroup) AS AgeGroupNotNull
FROM vw_ChurnPrediction_Features;

-- V√©rifier √©quilibre classes
SELECT 
    HasChurned,
    COUNT(*) AS Count,
    COUNT(*) * 100.0 / (SELECT COUNT(*) FROM vw_ChurnPrediction_Features) AS Percent
FROM vw_ChurnPrediction_Features
GROUP BY HasChurned;

/* R√âSULTAT ID√âAL:
HasChurned  Count  Percent
0           245    49%      ‚Üê √âquilibr√© ‚úì
1           255    51%
*/
```

---

## üìä EXTRACTION MDX (Pour Mining depuis Cube)

**Si features dans cube SSAS :**

```mdx
-- Extraire features depuis cube pour Mining
SELECT 
  {
    [Measures].[RecencyScore],
    [Measures].[FrequencyScore],
    [Measures].[MonetaryScore],
    [Measures].[TenureScore]
  } ON COLUMNS,

  [Dim Customer].[Customer Key].[Customer Key].Members ON ROWS

FROM [Shoes Cube]

WHERE [Dim Time].[Year].&[2024]
```

**Mais PR√âF√âRER vue SQL directe !**  
Mining Structure lit mieux depuis SQL Server que depuis Cube.

---

## üéì R√âSUM√â ULTRA-CONCIS

```
1. COMPRENDRE le probl√®me business
   ‚Üí Pourquoi le churn se produit r√©ellement ?

2. IDENTIFIER features candidates
   ‚Üí Directes + Agr√©g√©es + D√©riv√©es

3. TESTER pertinence
   ‚Üí Comparer Churn√©s vs Actifs
   ‚Üí Distribution diff√©rente = feature pertinente

4. TRANSFORMER
   ‚Üí Scores 1-5
   ‚Üí Cat√©gories
   ‚Üí Ratios

5. VALIDER
   ‚Üí Pas de leakage
   ‚Üí Pas de redondance
   ‚Üí 10-20 features max

R√àGLE D'OR:
Feature pertinente = Distribution DIFF√âRENTE entre classes
```

---

## ‚úÖ VUE SQL FINALE PR√äTE

La vue **`vw_ChurnPrediction_Features`** est maintenant pr√™te pour cr√©er la Mining Structure !

**Prochaine √©tape :** MINING_4_Mining_Structures.md  
(Cr√©ation structures SSAS avec ces features)

---

**üéØ Features = 90% du succ√®s. Temps investi ici = temps gagn√© plus tard !**
